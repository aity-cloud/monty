package generators

import (
	"fmt"
	"strings"
	"time"

	"github.com/iancoleman/strcase"
	"google.golang.org/genproto/googleapis/api/annotations"
	"google.golang.org/protobuf/compiler/protogen"
	"google.golang.org/protobuf/proto"
	"google.golang.org/protobuf/reflect/protoreflect"
	"google.golang.org/protobuf/types/descriptorpb"
)

type CLIGenerator struct{}

func (g CLIGenerator) Name() string {
	return "cli"
}

func (g CLIGenerator) Generate(gen *protogen.Plugin) error {
	for _, file := range gen.Files {
		if !file.Generate {
			continue
		}
		if !proto.HasExtension(file.Desc.Options(), E_Generator) {
			continue
		}
		ext := proto.GetExtension(file.Desc.Options(), E_Generator).(*GeneratorOptions)
		if !ext.GetGenerate() {
			continue
		}
		generateFile(gen, file)
	}
	return nil
}

// FileDescriptorProto.package field number
const fileDescriptorProtoPackageFieldNumber = 2

// FileDescriptorProto.syntax field number
const fileDescriptorProtoSyntaxFieldNumber = 12

var (
	_time      = protogen.GoImportPath("time")
	_fmt       = protogen.GoImportPath("fmt")
	_context   = protogen.GoImportPath("context")
	_protojson = protogen.GoImportPath("google.golang.org/protobuf/encoding/protojson")
	_cobra     = protogen.GoImportPath("github.com/spf13/cobra")
	_pflag     = protogen.GoImportPath("github.com/spf13/pflag")
	_emptypb   = protogen.GoImportPath("google.golang.org/protobuf/types/known/emptypb")
	_flagutil  = protogen.GoImportPath("github.com/rancher/opni/pkg/util/flagutil")
	_enumflag  = protogen.GoImportPath("github.com/thediveo/enumflag/v2")
)

func genLeadingComments(g *protogen.GeneratedFile, loc protoreflect.SourceLocation) {
	for _, s := range loc.LeadingDetachedComments {
		g.P(protogen.Comments(s))
		g.P()
	}
	if s := loc.LeadingComments; s != "" {
		g.P(protogen.Comments(s))
		g.P()
	}
}

func generateFile(gen *protogen.Plugin, file *protogen.File) *protogen.GeneratedFile {
	if len(file.Services) == 0 {
		return nil
	}
	filename := file.GeneratedFilenamePrefix + "_cli.pb.go"
	g := gen.NewGeneratedFile(filename, file.GoImportPath)
	// Attach all comments associated with the syntax field.
	genLeadingComments(g, file.Desc.SourceLocations().ByPath(protoreflect.SourcePath{fileDescriptorProtoSyntaxFieldNumber}))
	g.P("// Code generated by cli_gen.go DO NOT EDIT.")
	g.P("// source: ", file.Desc.Path())

	g.P()
	// Attach all comments associated with the package field.
	genLeadingComments(g, file.Desc.SourceLocations().ByPath(protoreflect.SourcePath{fileDescriptorProtoPackageFieldNumber}))
	g.P("package ", file.GoPackageName)
	g.P()
	generateFileContent(gen, file, g)
	return g
}

func generateFileContent(gen *protogen.Plugin, file *protogen.File, g *protogen.GeneratedFile) {
	opts := GeneratorOptions{}
	applyOptions(file.Desc, &opts)

	svcCtx := serviceGeneratorContext{}
	switch opts.ClientDependencyInjection {
	case ClientDependencyInjectionStrategy_InjectIntoContext:
		generateContextInjectionFunctions(gen, file, g)
		svcCtx = serviceGeneratorContext{
			PrintAddCmd: func(method *protogen.Method, g *protogen.GeneratedFile) {
				g.P("cmd.AddCommand(Build", method.GoName, "Cmd())")
			},
			PrintCmdBuilderSignature: func(methodName, svcName string, g *protogen.GeneratedFile) {
				g.P("func Build", methodName, "Cmd() *", _cobra.Ident("Command"), " {")
			},
			PrintObtainClient: func(service *protogen.Service, g *protogen.GeneratedFile) {
				g.P("client, ok := ", service.GoName+"ClientFromContext(cmd.Context())")
				g.P("if !ok {")
				g.P("cmd.PrintErrln(\"failed to get client from context\")")
				g.P("return nil")
				g.P("}")
			},
		}

	case ClientDependencyInjectionStrategy_InjectAsArgument:
		svcCtx = serviceGeneratorContext{
			PrintAddCmd: func(method *protogen.Method, g *protogen.GeneratedFile) {},
			PrintCmdBuilderSignature: func(methodName, svcName string, g *protogen.GeneratedFile) {
				g.P("func Build", methodName, "Cmd(client ", svcName+"Client", ") *", _cobra.Ident("Command"), " {")
			},
			PrintObtainClient: func(service *protogen.Service, g *protogen.GeneratedFile) {},
		}
	}
	g.P()
	for _, service := range file.Services {
		svcCtx.generateServiceTopLevelCmd(gen, file, service, g)
		g.P()
		for _, method := range service.Methods {
			svcCtx.generateMethodCmd(gen, file, service, method, g)
			g.P()
		}
	}
}

type serviceGeneratorContext struct {
	PrintAddCmd              func(method *protogen.Method, g *protogen.GeneratedFile)
	PrintCmdBuilderSignature func(methodName, svcName string, g *protogen.GeneratedFile)
	PrintObtainClient        func(service *protogen.Service, g *protogen.GeneratedFile)
}

func generateContextInjectionFunctions(gen *protogen.Plugin, file *protogen.File, g *protogen.GeneratedFile) {
	for _, service := range file.Services {
		g.P("type contextKey_", service.GoName, "_type struct{}")
		g.P("var contextKey_", service.GoName, " contextKey_", service.GoName, "_type")
		g.P()
		g.P("func ContextWith", service.GoName, "Client(ctx ", _context.Ident("Context"), ", client ", service.GoName, "Client) context.Context {")
		g.P("return context.WithValue(ctx, contextKey_", service.GoName, ", client)")
		g.P("}")
		g.P()
		g.P("func ", service.GoName, "ClientFromContext(ctx ", _context.Ident("Context"), ") (", service.GoName, "Client, bool) {")
		g.P("client, ok := ctx.Value(contextKey_", service.GoName, ").(", service.GoName, "Client)")
		g.P("return client, ok")
		g.P("}")
		g.P()
	}
}

func (gc *serviceGeneratorContext) generateServiceTopLevelCmd(gen *protogen.Plugin, file *protogen.File, service *protogen.Service, g *protogen.GeneratedFile) {
	leadingComments := formatComments(service.Comments)

	opts := CommandGroupOptions{
		Use: service.GoName,
	}
	applyOptions(service.Desc, &opts)

	gc.PrintCmdBuilderSignature(service.GoName, service.GoName, g)

	g.P("cmd := &", _cobra.Ident("Command"), "{")
	g.P(" Use:   \"", opts.Use, "\",")
	if len(leadingComments) > 0 {
		g.P(" Short: `", leadingComments[0], "`,")
	}
	if len(leadingComments) > 1 {
		g.P(" Long: `")
		for _, c := range leadingComments[1:] {
			g.P(c)
		}
		g.P("`[1:],")
	}
	if opts.GroupId != "" {
		g.P(" GroupID: \"", opts.GroupId, "\",")
	}

	g.P(" Args: cobra.NoArgs,")
	g.P(" ValidArgsFunction: cobra.NoFileCompletions,")

	g.P("}")
	g.P()

	for _, method := range service.Methods {
		gc.PrintAddCmd(method, g)
	}

	g.P("return cmd")
	g.P("}")
}

func (gc *serviceGeneratorContext) generateMethodCmd(gen *protogen.Plugin, file *protogen.File, service *protogen.Service, method *protogen.Method, g *protogen.GeneratedFile) {
	gc.PrintCmdBuilderSignature(method.GoName, service.GoName, g)
	isEmpty := method.Input.Desc.FullName() == "google.protobuf.Empty"
	if !isEmpty {
		g.P("input := &", g.QualifiedGoIdent(method.Input.GoIdent), "{}")
	}
	methodOptions := method.Desc.Options().(*descriptorpb.MethodOptions)
	leadingComments := formatComments(method.Comments)

	opts := CommandOptions{
		Use: method.GoName,
	}
	applyOptions(method.Desc, &opts)

	g.P("cmd := &", _cobra.Ident("Command"), "{")
	g.P(" Use:   \"", opts.Use, "\",")
	if len(leadingComments) > 0 {
		g.P(" Short: ", fmt.Sprintf("%q", leadingComments[0]), ",")
	}
	httpExt, hasHttpExt := getExtension[*annotations.HttpRule](method.Desc, annotations.E_Http)
	if len(leadingComments) > 1 || hasHttpExt {
		g.P(" Long: `")
		for _, c := range leadingComments[1:] {
			g.P(c)
		}
		if hasHttpExt {
			if len(leadingComments) > 1 {
				g.P()
			}
			g.P("HTTP handlers for this method:")
			g.P("- ", httpExt.String())
			for _, additionalRule := range httpExt.GetAdditionalBindings() {
				g.P("- ", additionalRule.String())
			}
		}
		g.P("`[1:],")
	}
	if methodOptions.GetDeprecated() {
		g.P(" Deprecated: \"", method.GoName, " is deprecated.\",")
	}

	g.P(" Args: cobra.NoArgs,")
	g.P(" ValidArgsFunction: cobra.NoFileCompletions,")

	gc.generateRun(gen, file, service, method, g)

	g.P("}")

	// Generate flags for input fields recursively
	if !isEmpty {
		g.P("cmd.Flags().AddFlagSet(input.FlagSet())")
		defer func() {
			g.P()
			generateFlagSet(g, method.Input, "input", "", method.Input.GoIdent.GoName)
		}()
	}

	for _, requiredFlag := range opts.RequiredFlags {
		g.P("cmd.MarkFlagRequired(\"", requiredFlag, "\")")
	}

	g.P("return cmd")
	g.P("}")
}

func generateFlagSet(g *protogen.GeneratedFile, message *protogen.Message, varName, prefix, parentName string) {
	g.P("func (input *", message.GoIdent.GoName, ") FlagSet() *", _pflag.Ident("FlagSet"), " {")
	g.P("fs := ", _pflag.Ident("NewFlagSet("), "\""+message.GoIdent.GoName+"\"", ", ", _pflag.Ident("ExitOnError"), ")")
	g.P("fs.SortFlags = true")

	// Generate flags for fields recursively
	generateFlags(g, message, varName, prefix, parentName)

	g.P("return fs")
	g.P("}")
}

type fieldTypeDefaults struct {
	defaultValue  string
	flagsFunction string
}

var defaultsForType = map[protoreflect.Kind]fieldTypeDefaults{
	protoreflect.BoolKind:     {"false", "BoolVar"},
	protoreflect.Int32Kind:    {"0", "Int32Var"},
	protoreflect.Sint32Kind:   {"0", "Int32Var"},
	protoreflect.Sfixed32Kind: {"0", "Int32Var"},
	protoreflect.Uint32Kind:   {"0", "Uint32Var"},
	protoreflect.Fixed32Kind:  {"0", "Uint32Var"},
	protoreflect.Int64Kind:    {"0", "Int64Var"},
	protoreflect.Sint64Kind:   {"0", "Int64Var"},
	protoreflect.Sfixed64Kind: {"0", "Int64Var"},
	protoreflect.Uint64Kind:   {"0", "Uint64Var"},
	protoreflect.Fixed64Kind:  {"0", "Uint64Var"},
	protoreflect.FloatKind:    {"0.0", "Float32Var"},
	protoreflect.DoubleKind:   {"0.0", "Float64Var"},
	protoreflect.StringKind:   {`""`, "StringVar"},
	protoreflect.BytesKind:    {"nil", "BytesHexVar"},
}

var stringToMapValueTypeDefaults = map[protoreflect.Kind]fieldTypeDefaults{
	protoreflect.StringKind:   {"nil", "StringToStringVar"},
	protoreflect.Int32Kind:    {"nil", "StringToIntVar"},
	protoreflect.Sint32Kind:   {"nil", "StringToIntVar"},
	protoreflect.Sfixed32Kind: {"nil", "StringToIntVar"},
	protoreflect.Uint32Kind:   {"nil", "StringToIntVar"},
	protoreflect.Fixed32Kind:  {"nil", "StringToIntVar"},
	protoreflect.Int64Kind:    {"nil", "StringToInt64Var"},
	protoreflect.Sint64Kind:   {"nil", "StringToInt64Var"},
	protoreflect.Sfixed64Kind: {"nil", "StringToInt64Var"},
	protoreflect.Uint64Kind:   {"nil", "StringToInt64Var"},
	protoreflect.Fixed64Kind:  {"nil", "StringToInt64Var"},
}

var specialCaseReplacements = map[string]string{
	"s-3": "s3",
}

func generateFlags(g *protogen.GeneratedFile, message *protogen.Message, varName, prefix, parentName string) {
	for _, field := range message.Fields {
		// Skip google.protobuf.Empty message
		if field.Message != nil && isEmptypb(field.Message.Desc) {
			continue
		}

		kebabName := strcase.ToKebab(field.GoName)
		if replacement, ok := specialCaseReplacements[kebabName]; ok {
			kebabName = replacement
		}
		fieldName := prefix + kebabName
		fieldVar := varName + "." + field.GoName
		comment := string(field.Comments.Leading)
		comment = strings.TrimSpace(strings.ReplaceAll(strings.ReplaceAll(comment, "//", ""), "\n", " "))

		var hasCustomDefault bool

		flagOpts := FlagOptions{}
		applyOptions(field.Desc, &flagOpts)
		if flagOpts.Default != "" {
			hasCustomDefault = true
			if field.Desc.Kind() == protoreflect.StringKind {
				flagOpts.Default = fmt.Sprintf("%q", flagOpts.Default)
			}
		}

		if field.Desc.Options().(*descriptorpb.FieldOptions).GetDeprecated() {
			g.P(`fs.MarkDeprecated("`, fieldName, `",`, fmt.Sprintf("%q", comment), `)`)
		}

		defaults, ok := defaultsForType[field.Desc.Kind()]
		if !ok {
			if field.Desc.IsMap() {
				if field.Desc.MapKey().Kind() == protoreflect.StringKind {
					defaults, ok = stringToMapValueTypeDefaults[field.Desc.MapValue().Kind()]
				}
			}
		}
		if ok {
			defaultValueStr := defaults.defaultValue
			flagsFunction := defaults.flagsFunction
			if field.Desc.IsList() {
				flagsFunction = strings.Replace(flagsFunction, "Var", "SliceVar", 1)
				if !hasCustomDefault {
					defaultValueStr = "nil"
				}
			}
			if defaultValueStr == "" {
				defaultValueStr = `""`
			}

			g.P(`fs.`, flagsFunction, `(&`, fieldVar, `, "`, fieldName, `", `, defaultValueStr, `,`, fmt.Sprintf("%q", comment), `)`)
			continue
		}

		switch field.Desc.Kind() {
		case protoreflect.EnumKind:
			g.P(`fs.Var(`, _enumflag.Ident("New"), `(&`, fieldVar, `, "`, field.Enum.Desc.Name(), `", map[`+g.QualifiedGoIdent(field.Enum.GoIdent)+`][]string{`)
			for _, v := range field.Enum.Values {
				g.P(g.QualifiedGoIdent(v.GoIdent), `: {`, fmt.Sprintf("%q", string(v.Desc.Name())), `},`)
			}
			g.P("},", _enumflag.Ident("EnumCaseSensitive"), `), "`, fieldName, `",`, fmt.Sprintf("%q", comment), `)`)
			continue
		case protoreflect.MessageKind:
			if field.Message.Desc.FullName() == "google.protobuf.Duration" {
				if !field.Desc.IsList() {
					g.P(append(append([]any{`fs.Var(`, _flagutil.Ident("DurationpbValue"), `(`}, unparseDuration(flagOpts.Default)...), `, &`, fieldVar, `), "`, fieldName, `",`, fmt.Sprintf("%q", comment), `)`)...)
				} else {
					g.P(append(append([]any{`fs.Var(`, _flagutil.Ident("DurationpbSliceValue"), `(`}, unparseDurationList(flagOpts.Default)...), `, &`, fieldVar, `), "`, fieldName, `",`, fmt.Sprintf("%q", comment), `)`)...)
				}
				continue
			}
			// Generate flags for nested messages
			g.P("if ", fieldVar, " == nil {")
			g.P("  ", fieldVar, " = &", field.Message.GoIdent, "{}")
			g.P("}")
			generateFlags(g, field.Message, fieldVar, fieldName+".", parentName+"."+field.GoName)
			continue
		}

	}
}

// converts a duration string (e.g. "1h", "15m", 2h30m) into the equivalent go syntax
// string (e.g. "1*time.Hour", "15*time.Minute", "2*time.Hour+30*time.Minute")
func unparseDuration(durationStr string) (tokens []any) {
	if durationStr == "" {
		tokens = append(tokens, "0")
		return
	}

	duration, err := time.ParseDuration(durationStr)
	if err != nil {
		panic(fmt.Sprintf("invalid duration %q: %v", durationStr, err))
	}

	if duration == 0 {
		tokens = append(tokens, "0")
		return
	}

	h := duration / time.Hour
	m := (duration - (h * time.Hour)) / time.Minute
	s := (duration - (h * time.Hour) - (m * time.Minute)) / time.Second
	ms := (duration - (h * time.Hour) - (m * time.Minute) - (s * time.Second)) / time.Millisecond
	us := (duration - (h * time.Hour) - (m * time.Minute) - (s * time.Second) - (ms * time.Millisecond)) / time.Microsecond
	ns := (duration - (h * time.Hour) - (m * time.Minute) - (s * time.Second) - (ms * time.Millisecond) - (us * time.Microsecond)) / time.Nanosecond

	plus := []any{}
	if h != 0 {
		tokens = append(tokens, fmt.Sprintf("%d*", h), _time.Ident("Hour"))
		plus = []any{"+"}
	}
	if m != 0 {
		tokens = append(append(tokens, plus...), fmt.Sprintf("%d*", m), _time.Ident("Minute"))
		plus = []any{"+"}
	}
	if s != 0 {
		tokens = append(append(tokens, plus...), fmt.Sprintf("%d*", s), _time.Ident("Second"))
		plus = []any{"+"}
	}
	if ms != 0 {
		tokens = append(append(tokens, plus...), fmt.Sprintf("%d*", ms), _time.Ident("Millisecond"))
		plus = []any{"+"}
	}
	if us != 0 {
		tokens = append(append(tokens, plus...), fmt.Sprintf("%d*", us), _time.Ident("Microsecond"))
		plus = []any{"+"}
	}
	if ns != 0 {
		tokens = append(append(tokens, plus...), fmt.Sprintf("%d*", ns), _time.Ident("Nanosecond"))
	}
	return
}

func unparseDurationList(commaSeparatedDurations string) (tokens []any) {
	tokens = append(tokens, "[]", _time.Ident("Duration"), "{")
	for _, durationStr := range strings.Split(commaSeparatedDurations, ",") {
		tokens = append(tokens, unparseDuration(durationStr)...)
		tokens = append(tokens, ",")
	}
	return append(tokens, "}")
}

func formatComments(comments protogen.CommentSet) (leadingComments []string) {
	leadingComments = strings.Split(strings.TrimSuffix(comments.Leading.String(), "\n"), "\n")
	for i, c := range leadingComments {
		leadingComments[i] = strings.TrimLeft(c, " /")
	}
	return
}

type runnerGenerator interface {
	GenRunE(gen *protogen.Plugin, file *protogen.File, service *protogen.Service, method *protogen.Method, g *protogen.GeneratedFile)
}

type runnerGeneratorFunc func(gen *protogen.Plugin, file *protogen.File, service *protogen.Service, method *protogen.Method, g *protogen.GeneratedFile)

func (f runnerGeneratorFunc) GenRunE(gen *protogen.Plugin, file *protogen.File, service *protogen.Service, method *protogen.Method, g *protogen.GeneratedFile) {
	f(gen, file, service, method, g)
}

var (
	exampleRunnerGenerator runnerGeneratorFunc = func(gen *protogen.Plugin, file *protogen.File, service *protogen.Service, method *protogen.Method, g *protogen.GeneratedFile) {
		g.P("response, err := client.", method.GoName, "(cmd.Context(), input)")
		g.P("if err != nil {")
		g.P("  return err")
		g.P("}")
		g.P("cmd.Println(", _protojson.Ident("MarshalOptions"), "{Multiline: true, EmitUnpopulated: true}.Format(response))")
		g.P("return nil")
	}

	setterRunnerGenerator runnerGeneratorFunc = func(gen *protogen.Plugin, file *protogen.File, service *protogen.Service, method *protogen.Method, g *protogen.GeneratedFile) {
		g.P("_, err := client.", method.GoName, "(cmd.Context(), input)")
		g.P("return err")
	}

	getterRunnerGenerator runnerGeneratorFunc = func(gen *protogen.Plugin, file *protogen.File, service *protogen.Service, method *protogen.Method, g *protogen.GeneratedFile) {
		g.P("response, err := client.", method.GoName, "(cmd.Context(), &", _emptypb.Ident("Empty"), "{})")
		g.P("if err != nil {")
		g.P("  return err")
		g.P("}")
		g.P("cmd.Println(", _protojson.Ident("MarshalOptions"), "{Multiline: true, EmitUnpopulated: true}.Format(response))")
		g.P("return nil")
	}

	emptyRunnerGenerator runnerGeneratorFunc = func(gen *protogen.Plugin, file *protogen.File, service *protogen.Service, method *protogen.Method, g *protogen.GeneratedFile) {
		g.P("_, err := client.", method.GoName, "(cmd.Context(), &", _emptypb.Ident("Empty"), "{})")
		g.P("return err")
	}
)

func (gc *serviceGeneratorContext) generateRun(gen *protogen.Plugin, file *protogen.File, service *protogen.Service, method *protogen.Method, g *protogen.GeneratedFile) {
	runnerGen, err := determineBestGenerator(method)
	if err != nil {
		gen.Error(err)
		return
	}
	g.P(" RunE: func(cmd *", _cobra.Ident("Command"), ", args []string) error {")
	gc.PrintObtainClient(service, g)
	runnerGen.GenRunE(gen, file, service, method, g)
	g.P("},")
}

// examines the method and options to decide which generator to use
func determineBestGenerator(method *protogen.Method) (runnerGenerator, error) {
	// check for a few distinct patterns based on the input and output types

	// 1. request not empty, response empty: use the "setter" pattern
	requestIsEmpty := isEmptypb(method.Desc.Input())
	responseIsEmpty := isEmptypb(method.Desc.Output())

	if !requestIsEmpty && responseIsEmpty {
		return setterRunnerGenerator, nil
	}

	// 2. request empty, response not empty: use the "getter" pattern
	if requestIsEmpty && !responseIsEmpty {
		return getterRunnerGenerator, nil
	}

	// 3. request not empty, response not empty: use the "example" pattern
	if !requestIsEmpty && !responseIsEmpty {
		return exampleRunnerGenerator, nil
	}

	// 4. request empty, response empty: use the "empty" pattern
	if requestIsEmpty && responseIsEmpty {
		return emptyRunnerGenerator, nil
	}

	return nil, fmt.Errorf("could not determine runner generator for method %s", method.GoName)
}

func isEmptypb(t protoreflect.MessageDescriptor) bool {
	return t.FullName() == "google.protobuf.Empty"
}

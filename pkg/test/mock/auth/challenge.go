// Code generated by MockGen. DO NOT EDIT.
// Source: pkg/auth/challenges/handlers.go

// Package mock_challenges is a generated GoMock package.
package mock_challenges

import (
	context "context"
	reflect "reflect"

	gomock "github.com/golang/mock/gomock"
	challenges "github.com/rancher/opni/pkg/auth/challenges"
	streams "github.com/rancher/opni/pkg/util/streams"
)

// MockChallengeHandler is a mock of ChallengeHandler interface.
type MockChallengeHandler struct {
	ctrl     *gomock.Controller
	recorder *MockChallengeHandlerMockRecorder
}

// MockChallengeHandlerMockRecorder is the mock recorder for MockChallengeHandler.
type MockChallengeHandlerMockRecorder struct {
	mock *MockChallengeHandler
}

// NewMockChallengeHandler creates a new mock instance.
func NewMockChallengeHandler(ctrl *gomock.Controller) *MockChallengeHandler {
	mock := &MockChallengeHandler{ctrl: ctrl}
	mock.recorder = &MockChallengeHandlerMockRecorder{mock}
	return mock
}

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockChallengeHandler) EXPECT() *MockChallengeHandlerMockRecorder {
	return m.recorder
}

// DoChallenge mocks base method.
func (m *MockChallengeHandler) DoChallenge(stream streams.Stream) (context.Context, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "DoChallenge", stream)
	ret0, _ := ret[0].(context.Context)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// DoChallenge indicates an expected call of DoChallenge.
func (mr *MockChallengeHandlerMockRecorder) DoChallenge(stream interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "DoChallenge", reflect.TypeOf((*MockChallengeHandler)(nil).DoChallenge), stream)
}

// InterceptContext mocks base method.
func (m *MockChallengeHandler) InterceptContext(ctx context.Context) context.Context {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "InterceptContext", ctx)
	ret0, _ := ret[0].(context.Context)
	return ret0
}

// InterceptContext indicates an expected call of InterceptContext.
func (mr *MockChallengeHandlerMockRecorder) InterceptContext(ctx interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "InterceptContext", reflect.TypeOf((*MockChallengeHandler)(nil).InterceptContext), ctx)
}

// MockconditionalThen is a mock of conditionalThen interface.
type MockconditionalThen struct {
	ctrl     *gomock.Controller
	recorder *MockconditionalThenMockRecorder
}

// MockconditionalThenMockRecorder is the mock recorder for MockconditionalThen.
type MockconditionalThenMockRecorder struct {
	mock *MockconditionalThen
}

// NewMockconditionalThen creates a new mock instance.
func NewMockconditionalThen(ctrl *gomock.Controller) *MockconditionalThen {
	mock := &MockconditionalThen{ctrl: ctrl}
	mock.recorder = &MockconditionalThenMockRecorder{mock}
	return mock
}

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockconditionalThen) EXPECT() *MockconditionalThenMockRecorder {
	return m.recorder
}

// Then mocks base method.
func (m *MockconditionalThen) Then(challenge challenges.ChallengeHandler) conditionalElse {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Then", challenge)
	ret0, _ := ret[0].(conditionalElse)
	return ret0
}

// Then indicates an expected call of Then.
func (mr *MockconditionalThenMockRecorder) Then(challenge interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Then", reflect.TypeOf((*MockconditionalThen)(nil).Then), challenge)
}

// MockconditionalElse is a mock of conditionalElse interface.
type MockconditionalElse struct {
	ctrl     *gomock.Controller
	recorder *MockconditionalElseMockRecorder
}

// MockconditionalElseMockRecorder is the mock recorder for MockconditionalElse.
type MockconditionalElseMockRecorder struct {
	mock *MockconditionalElse
}

// NewMockconditionalElse creates a new mock instance.
func NewMockconditionalElse(ctrl *gomock.Controller) *MockconditionalElse {
	mock := &MockconditionalElse{ctrl: ctrl}
	mock.recorder = &MockconditionalElseMockRecorder{mock}
	return mock
}

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockconditionalElse) EXPECT() *MockconditionalElseMockRecorder {
	return m.recorder
}

// DoChallenge mocks base method.
func (m *MockconditionalElse) DoChallenge(stream streams.Stream) (context.Context, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "DoChallenge", stream)
	ret0, _ := ret[0].(context.Context)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// DoChallenge indicates an expected call of DoChallenge.
func (mr *MockconditionalElseMockRecorder) DoChallenge(stream interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "DoChallenge", reflect.TypeOf((*MockconditionalElse)(nil).DoChallenge), stream)
}

// Else mocks base method.
func (m *MockconditionalElse) Else(challenge challenges.ChallengeHandler) challenges.ChallengeHandler {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Else", challenge)
	ret0, _ := ret[0].(challenges.ChallengeHandler)
	return ret0
}

// Else indicates an expected call of Else.
func (mr *MockconditionalElseMockRecorder) Else(challenge interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Else", reflect.TypeOf((*MockconditionalElse)(nil).Else), challenge)
}

// InterceptContext mocks base method.
func (m *MockconditionalElse) InterceptContext(ctx context.Context) context.Context {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "InterceptContext", ctx)
	ret0, _ := ret[0].(context.Context)
	return ret0
}

// InterceptContext indicates an expected call of InterceptContext.
func (mr *MockconditionalElseMockRecorder) InterceptContext(ctx interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "InterceptContext", reflect.TypeOf((*MockconditionalElse)(nil).InterceptContext), ctx)
}

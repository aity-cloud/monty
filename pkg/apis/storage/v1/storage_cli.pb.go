// Code generated by cli_gen.go DO NOT EDIT.
// source: github.com/rancher/opni/pkg/apis/storage/v1/storage.proto

package v1

import (
	errors "errors"
	flagutil "github.com/rancher/opni/pkg/util/flagutil"
	pflag "github.com/spf13/pflag"
	os "os"
	strings "strings"
)

func (input *StorageSpec) FlagSet(prefix ...string) *pflag.FlagSet {
	fs := pflag.NewFlagSet("StorageSpec", pflag.ExitOnError)
	fs.SortFlags = true
	fs.StringVar(&input.Backend, strings.Join(append(prefix, "backend"), "."), "filesystem", "Name of the storage backend to use. (s3|gcs|azure|swift|filesystem)")
	if input.S3 == nil {
		input.S3 = &S3StorageSpec{}
	}
	fs.AddFlagSet(input.S3.FlagSet(append(prefix, "s3")...))
	if input.Gcs == nil {
		input.Gcs = &GCSStorageSpec{}
	}
	fs.AddFlagSet(input.Gcs.FlagSet(append(prefix, "gcs")...))
	if input.Azure == nil {
		input.Azure = &AzureStorageSpec{}
	}
	fs.AddFlagSet(input.Azure.FlagSet(append(prefix, "azure")...))
	if input.Swift == nil {
		input.Swift = &SwiftStorageSpec{}
	}
	fs.AddFlagSet(input.Swift.FlagSet(append(prefix, "swift")...))
	if input.Filesystem == nil {
		input.Filesystem = &FilesystemStorageSpec{}
	}
	fs.AddFlagSet(input.Filesystem.FlagSet(append(prefix, "filesystem")...))
	fs.Var(flagutil.DurationpbValue(0, &input.RetentionPeriod), strings.Join(append(prefix, "retention-period"), "."), "Retention period for persisted data. If 0, data will be retained indefinitely.")
	return fs
}

func (input *StorageSpec) RedactSecrets() {
	if input == nil {
		return
	}
	input.S3.RedactSecrets()
	input.Gcs.RedactSecrets()
	input.Azure.RedactSecrets()
	input.Swift.RedactSecrets()
}

func (input *StorageSpec) UnredactSecrets(unredacted *StorageSpec) error {
	if input == nil {
		return nil
	}
	if err := input.S3.UnredactSecrets(unredacted.GetS3()); err != nil {
		return err
	}
	if err := input.Gcs.UnredactSecrets(unredacted.GetGcs()); err != nil {
		return err
	}
	if err := input.Azure.UnredactSecrets(unredacted.GetAzure()); err != nil {
		return err
	}
	if err := input.Swift.UnredactSecrets(unredacted.GetSwift()); err != nil {
		return err
	}
	return nil
}

func (input *S3StorageSpec) FlagSet(prefix ...string) *pflag.FlagSet {
	fs := pflag.NewFlagSet("S3StorageSpec", pflag.ExitOnError)
	fs.SortFlags = true
	fs.StringVar(&input.Endpoint, strings.Join(append(prefix, "endpoint"), "."), "", "The S3 bucket endpoint. It could be an AWS S3 endpoint listed at  https:docs.aws.amazon.com/general/latest/gr/s3.html or the address of an  S3-compatible service in hostname:port format.")
	fs.StringVar(&input.Region, strings.Join(append(prefix, "region"), "."), "", "S3 region. If unset, the client will issue a S3 GetBucketLocation API call  to autodetect it.")
	fs.StringVar(&input.BucketName, strings.Join(append(prefix, "bucket-name"), "."), "", "S3 bucket name")
	fs.StringVar(&input.SecretAccessKey, strings.Join(append(prefix, "secret-access-key"), "."), "", "\x1b[31m[secret]\x1b[0m S3 secret access key")
	fs.StringVar(&input.AccessKeyID, strings.Join(append(prefix, "access-key-id"), "."), "", "S3 access key ID")
	fs.BoolVar(&input.Insecure, strings.Join(append(prefix, "insecure"), "."), false, "If enabled, use http: for the S3 endpoint instead of https:. This could  be useful in local dev/test environments while using an S3-compatible  backend storage, like Minio.")
	fs.StringVar(&input.SignatureVersion, strings.Join(append(prefix, "signature-version"), "."), "", "The signature version to use for authenticating against S3.  Supported values are: v4, v2")
	if input.Sse == nil {
		input.Sse = &SSEConfig{}
	}
	fs.AddFlagSet(input.Sse.FlagSet(append(prefix, "sse")...))
	if input.Http == nil {
		input.Http = &HTTPConfig{}
	}
	fs.AddFlagSet(input.Http.FlagSet(append(prefix, "http")...))
	return fs
}

func (input *S3StorageSpec) RedactSecrets() {
	if input == nil {
		return
	}
	if input.SecretAccessKey != "" {
		input.SecretAccessKey = "***"
	}
	input.Sse.RedactSecrets()
}

func (input *S3StorageSpec) UnredactSecrets(unredacted *S3StorageSpec) error {
	if input == nil {
		return nil
	}
	if input.SecretAccessKey == "***" {
		if unredacted.GetSecretAccessKey() == "" {
			return errors.New("cannot unredact: missing value for secret field: SecretAccessKey")
		}
		input.SecretAccessKey = unredacted.SecretAccessKey
	}
	if err := input.Sse.UnredactSecrets(unredacted.GetSse()); err != nil {
		return err
	}
	return nil
}

func (input *SSEConfig) FlagSet(prefix ...string) *pflag.FlagSet {
	fs := pflag.NewFlagSet("SSEConfig", pflag.ExitOnError)
	fs.SortFlags = true
	fs.StringVar(&input.Type, strings.Join(append(prefix, "type"), "."), "", "Enable AWS Server Side Encryption. Supported values: SSE-KMS, SSE-S3")
	fs.StringVar(&input.KmsKeyID, strings.Join(append(prefix, "kms-key-id"), "."), "", "KMS Key ID used to encrypt objects in S3")
	fs.StringVar(&input.KmsEncryptionContext, strings.Join(append(prefix, "kms-encryption-context"), "."), "", "\x1b[31m[secret]\x1b[0m KMS Encryption Context used for object encryption. It expects a JSON formatted string.")
	return fs
}

func (input *SSEConfig) RedactSecrets() {
	if input == nil {
		return
	}
	if input.KmsEncryptionContext != "" {
		input.KmsEncryptionContext = "***"
	}
}

func (input *SSEConfig) UnredactSecrets(unredacted *SSEConfig) error {
	if input == nil {
		return nil
	}
	if input.KmsEncryptionContext == "***" {
		if unredacted.GetKmsEncryptionContext() == "" {
			return errors.New("cannot unredact: missing value for secret field: KmsEncryptionContext")
		}
		input.KmsEncryptionContext = unredacted.KmsEncryptionContext
	}
	return nil
}

func (input *HTTPConfig) FlagSet(prefix ...string) *pflag.FlagSet {
	fs := pflag.NewFlagSet("HTTPConfig", pflag.ExitOnError)
	fs.SortFlags = true
	fs.Var(flagutil.DurationpbValue(0, &input.IdleConnTimeout), strings.Join(append(prefix, "idle-conn-timeout"), "."), "The time an idle connection will remain idle before closing.")
	fs.Var(flagutil.DurationpbValue(0, &input.ResponseHeaderTimeout), strings.Join(append(prefix, "response-header-timeout"), "."), "The amount of time the client will wait for a servers response headers.")
	fs.BoolVar(&input.InsecureSkipVerify, strings.Join(append(prefix, "insecure-skip-verify"), "."), false, "If the client connects via HTTPS and this option is enabled, the client will accept any certificate and hostname.")
	fs.Var(flagutil.DurationpbValue(0, &input.TlsHandshakeTimeout), strings.Join(append(prefix, "tls-handshake-timeout"), "."), "Maximum time to wait for a TLS handshake. 0 means no limit.")
	fs.Var(flagutil.DurationpbValue(0, &input.ExpectContinueTimeout), strings.Join(append(prefix, "expect-continue-timeout"), "."), "The time to wait for a server's first response headers after fully writing the request headers if the request has an Expect header. 0 to send the request body immediately.")
	fs.Int32Var(&input.MaxIdleConns, strings.Join(append(prefix, "max-idle-conns"), "."), 0, "Maximum number of idle (keep-alive) connections across all hosts. 0 means no limit.")
	fs.Int32Var(&input.MaxIdleConnsPerHost, strings.Join(append(prefix, "max-idle-conns-per-host"), "."), 0, "Maximum number of idle (keep-alive) connections to keep per-host. If 0, a built-in default value is used.")
	fs.Int32Var(&input.MaxConnsPerHost, strings.Join(append(prefix, "max-conns-per-host"), "."), 0, "Maximum number of connections per host. 0 means no limit.")
	return fs
}

func (input *GCSStorageSpec) FlagSet(prefix ...string) *pflag.FlagSet {
	fs := pflag.NewFlagSet("GCSStorageSpec", pflag.ExitOnError)
	fs.SortFlags = true
	fs.StringVar(&input.BucketName, strings.Join(append(prefix, "bucket-name"), "."), "", "GCS bucket name")
	fs.StringVar(&input.ServiceAccount, strings.Join(append(prefix, "service-account"), "."), "", "\x1b[31m[secret]\x1b[0m JSON representing either a Google Developers Console client_credentials.json file  or a Google Developers service account key file. If empty, fallback to Google default logic.")
	return fs
}

func (input *GCSStorageSpec) RedactSecrets() {
	if input == nil {
		return
	}
	if input.ServiceAccount != "" {
		input.ServiceAccount = "***"
	}
}

func (input *GCSStorageSpec) UnredactSecrets(unredacted *GCSStorageSpec) error {
	if input == nil {
		return nil
	}
	if input.ServiceAccount == "***" {
		if unredacted.GetServiceAccount() == "" {
			return errors.New("cannot unredact: missing value for secret field: ServiceAccount")
		}
		input.ServiceAccount = unredacted.ServiceAccount
	}
	return nil
}

func (input *AzureStorageSpec) FlagSet(prefix ...string) *pflag.FlagSet {
	fs := pflag.NewFlagSet("AzureStorageSpec", pflag.ExitOnError)
	fs.SortFlags = true
	fs.StringVar(&input.StorageAccountName, strings.Join(append(prefix, "storage-account-name"), "."), "", "Azure storage account name")
	fs.StringVar(&input.StorageAccountKey, strings.Join(append(prefix, "storage-account-key"), "."), "", "\x1b[31m[secret]\x1b[0m Azure storage account key")
	fs.StringVar(&input.ContainerName, strings.Join(append(prefix, "container-name"), "."), "", "Azure storage container name")
	fs.StringVar(&input.Endpoint, strings.Join(append(prefix, "endpoint"), "."), "", "Azure storage endpoint suffix without schema. The account name will be  prefixed to this value to create the FQDN")
	fs.Int32Var(&input.MaxRetries, strings.Join(append(prefix, "max-retries"), "."), 0, "Number of retries for recoverable errors")
	fs.StringVar(&input.MsiResource, strings.Join(append(prefix, "msi-resource"), "."), "", "\x1b[31m[secret]\x1b[0m Azure storage MSI resource. Either this or account key must be set.")
	fs.StringVar(&input.UserAssignedID, strings.Join(append(prefix, "user-assigned-id"), "."), "", "Azure storage MSI resource managed identity client Id. If not supplied system assigned identity is used")
	if input.Http == nil {
		input.Http = &HTTPConfig{}
	}
	fs.AddFlagSet(input.Http.FlagSet(append(prefix, "http")...))
	return fs
}

func (input *AzureStorageSpec) RedactSecrets() {
	if input == nil {
		return
	}
	if input.StorageAccountKey != "" {
		input.StorageAccountKey = "***"
	}
	if input.MsiResource != "" {
		input.MsiResource = "***"
	}
}

func (input *AzureStorageSpec) UnredactSecrets(unredacted *AzureStorageSpec) error {
	if input == nil {
		return nil
	}
	if input.StorageAccountKey == "***" {
		if unredacted.GetStorageAccountKey() == "" {
			return errors.New("cannot unredact: missing value for secret field: StorageAccountKey")
		}
		input.StorageAccountKey = unredacted.StorageAccountKey
	}
	if input.MsiResource == "***" {
		if unredacted.GetMsiResource() == "" {
			return errors.New("cannot unredact: missing value for secret field: MsiResource")
		}
		input.MsiResource = unredacted.MsiResource
	}
	return nil
}

func (input *SwiftStorageSpec) FlagSet(prefix ...string) *pflag.FlagSet {
	fs := pflag.NewFlagSet("SwiftStorageSpec", pflag.ExitOnError)
	fs.SortFlags = true
	fs.Int32Var(&input.AuthVersion, strings.Join(append(prefix, "auth-version"), "."), 0, "OpenStack Swift authentication API version. 0 to autodetect.")
	fs.StringVar(&input.AuthURL, strings.Join(append(prefix, "auth-url"), "."), os.Getenv("OS_AUTH_URL"), "OpenStack Swift authentication URL. ($OS_AUTH_URL)")
	fs.StringVar(&input.Username, strings.Join(append(prefix, "username"), "."), os.Getenv("OS_USERNAME"), "OpenStack Swift username. ($OS_USERNAME)")
	fs.StringVar(&input.UserDomainName, strings.Join(append(prefix, "user-domain-name"), "."), os.Getenv("OS_USER_DOMAIN_NAME"), "OpenStack Swift user's domain name. ($OS_USER_DOMAIN_NAME)")
	fs.StringVar(&input.UserDomainID, strings.Join(append(prefix, "user-domain-id"), "."), os.Getenv("OS_USER_DOMAIN_ID"), "OpenStack Swift user's domain ID. ($OS_USER_DOMAIN_ID)")
	fs.StringVar(&input.UserID, strings.Join(append(prefix, "user-id"), "."), os.Getenv("OS_USER_ID"), "OpenStack Swift user ID. ($OS_USER_ID)")
	fs.StringVar(&input.Password, strings.Join(append(prefix, "password"), "."), os.Getenv("OS_PASSWORD"), "\x1b[31m[secret]\x1b[0m OpenStack Swift API key. ($OS_PASSWORD)")
	fs.StringVar(&input.DomainID, strings.Join(append(prefix, "domain-id"), "."), os.Getenv("OS_USER_DOMAIN_ID"), "OpenStack Swift user's domain ID. ($OS_USER_DOMAIN_ID)")
	fs.StringVar(&input.DomainName, strings.Join(append(prefix, "domain-name"), "."), os.Getenv("OS_USER_DOMAIN_NAME"), "OpenStack Swift user's domain name. ($OS_USER_DOMAIN_NAME)")
	fs.StringVar(&input.ProjectID, strings.Join(append(prefix, "project-id"), "."), "", "OpenStack Swift project ID (v2,v3 auth only).")
	fs.StringVar(&input.ProjectName, strings.Join(append(prefix, "project-name"), "."), os.Getenv("OS_PROJECT_NAME"), "OpenStack Swift project name (v2,v3 auth only). ($OS_PROJECT_NAME)")
	fs.StringVar(&input.ProjectDomainID, strings.Join(append(prefix, "project-domain-id"), "."), os.Getenv("OS_PROJECT_DOMAIN_ID"), "ID of the OpenStack Swift project's domain (v3 auth only), only needed  if it differs the from user domain. ($OS_PROJECT_DOMAIN_ID)")
	fs.StringVar(&input.ProjectDomainName, strings.Join(append(prefix, "project-domain-name"), "."), os.Getenv("OS_PROJECT_DOMAIN_NAME"), "Name of the OpenStack Swift project's domain (v3 auth only), only needed  if it differs from the user domain. ($OS_PROJECT_DOMAIN_NAME)")
	fs.StringVar(&input.RegionName, strings.Join(append(prefix, "region-name"), "."), os.Getenv("OS_REGION_NAME"), "OpenStack Swift Region to use (v2,v3 auth only). ($OS_REGION_NAME)")
	fs.StringVar(&input.ContainerName, strings.Join(append(prefix, "container-name"), "."), "", "Name of the OpenStack Swift container to use. The container must already  exist.")
	fs.Int32Var(&input.MaxRetries, strings.Join(append(prefix, "max-retries"), "."), 0, "Max number of times to retry failed requests.")
	fs.Var(flagutil.DurationpbValue(0, &input.ConnectTimeout), strings.Join(append(prefix, "connect-timeout"), "."), "Time after which a connection attempt is aborted.")
	fs.Var(flagutil.DurationpbValue(0, &input.RequestTimeout), strings.Join(append(prefix, "request-timeout"), "."), "Time after which an idle request is aborted. The timeout watchdog is reset  each time some data is received, so the timeout triggers after X time no  data is received on a request.")
	return fs
}

func (input *SwiftStorageSpec) RedactSecrets() {
	if input == nil {
		return
	}
	if input.Password != "" {
		input.Password = "***"
	}
}

func (input *SwiftStorageSpec) UnredactSecrets(unredacted *SwiftStorageSpec) error {
	if input == nil {
		return nil
	}
	if input.Password == "***" {
		if unredacted.GetPassword() == "" {
			return errors.New("cannot unredact: missing value for secret field: Password")
		}
		input.Password = unredacted.Password
	}
	return nil
}

func (input *FilesystemStorageSpec) FlagSet(prefix ...string) *pflag.FlagSet {
	fs := pflag.NewFlagSet("FilesystemStorageSpec", pflag.ExitOnError)
	fs.SortFlags = true
	fs.StringVar(&input.Directory, strings.Join(append(prefix, "directory"), "."), "", "Local filesystem storage directory.")
	return fs
}

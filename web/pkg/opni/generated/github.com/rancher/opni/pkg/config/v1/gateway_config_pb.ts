// @generated by protoc-gen-es v1.3.0 with parameter "target=ts,import_extension=none,ts_nocheck=false"
// @generated from file github.com/rancher/opni/pkg/config/v1/gateway_config.proto (package config.v1, syntax proto3)
/* eslint-disable */

import type { BinaryReadOptions, FieldList, JsonReadOptions, JsonValue, PartialMessage, PlainMessage } from "@bufbuild/protobuf";
import { Message, proto3 } from "@bufbuild/protobuf";
import { Revision } from "../../apis/core/v1/core_pb";

/**
 * @generated from enum config.v1.StorageBackend
 */
export enum StorageBackend {
  /**
   * Use etcd for key-value storage. This is the recommended default.
   *
   * @generated from enum value: Etcd = 0;
   */
  Etcd = 0,

  /**
   * Use NATS JetStream for key-value storage.
   *
   * @generated from enum value: JetStream = 1;
   */
  JetStream = 1,
}
// Retrieve enum metadata with: proto3.getEnumType(StorageBackend)
proto3.util.setEnumType(StorageBackend, "config.v1.StorageBackend", [
  { no: 0, name: "Etcd" },
  { no: 1, name: "JetStream" },
]);

/**
 * @generated from enum config.v1.PatchEngine
 */
export enum PatchEngine {
  /**
   * @generated from enum value: Bsdiff = 0;
   */
  Bsdiff = 0,

  /**
   * @generated from enum value: Zstd = 1;
   */
  Zstd = 1,
}
// Retrieve enum metadata with: proto3.getEnumType(PatchEngine)
proto3.util.setEnumType(PatchEngine, "config.v1.PatchEngine", [
  { no: 0, name: "Bsdiff" },
  { no: 1, name: "Zstd" },
]);

/**
 * @generated from enum config.v1.CacheBackend
 */
export enum CacheBackend {
  /**
   * @generated from enum value: Filesystem = 0;
   */
  Filesystem = 0,
}
// Retrieve enum metadata with: proto3.getEnumType(CacheBackend)
proto3.util.setEnumType(CacheBackend, "config.v1.CacheBackend", [
  { no: 0, name: "Filesystem" },
]);

/**
 * @generated from message config.v1.GatewayConfigSpec
 */
export class GatewayConfigSpec extends Message<GatewayConfigSpec> {
  /**
   * @generated from field: core.Revision revision = 1;
   */
  revision?: Revision;

  /**
   * @generated from field: config.v1.ServerSpec server = 2;
   */
  server?: ServerSpec;

  /**
   * @generated from field: config.v1.ManagementServerSpec management = 3;
   */
  management?: ManagementServerSpec;

  /**
   * @generated from field: config.v1.RelayServerSpec relay = 4;
   */
  relay?: RelayServerSpec;

  /**
   * @generated from field: config.v1.HealthServerSpec health = 5;
   */
  health?: HealthServerSpec;

  /**
   * @generated from field: config.v1.DashboardServerSpec dashboard = 6;
   */
  dashboard?: DashboardServerSpec;

  /**
   * @generated from field: config.v1.StorageSpec storage = 7;
   */
  storage?: StorageSpec;

  /**
   * @generated from field: config.v1.CertsSpec certs = 8;
   */
  certs?: CertsSpec;

  /**
   * @generated from field: config.v1.PluginsSpec plugins = 9;
   */
  plugins?: PluginsSpec;

  /**
   * @generated from field: config.v1.KeyringSpec keyring = 10;
   */
  keyring?: KeyringSpec;

  /**
   * @generated from field: config.v1.UpgradesSpec upgrades = 11;
   */
  upgrades?: UpgradesSpec;

  /**
   * @generated from field: config.v1.RateLimitingSpec rateLimiting = 12;
   */
  rateLimiting?: RateLimitingSpec;

  /**
   * @generated from field: config.v1.AuthSpec auth = 13;
   */
  auth?: AuthSpec;

  constructor(data?: PartialMessage<GatewayConfigSpec>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "config.v1.GatewayConfigSpec";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "revision", kind: "message", T: Revision },
    { no: 2, name: "server", kind: "message", T: ServerSpec },
    { no: 3, name: "management", kind: "message", T: ManagementServerSpec },
    { no: 4, name: "relay", kind: "message", T: RelayServerSpec },
    { no: 5, name: "health", kind: "message", T: HealthServerSpec },
    { no: 6, name: "dashboard", kind: "message", T: DashboardServerSpec },
    { no: 7, name: "storage", kind: "message", T: StorageSpec },
    { no: 8, name: "certs", kind: "message", T: CertsSpec },
    { no: 9, name: "plugins", kind: "message", T: PluginsSpec },
    { no: 10, name: "keyring", kind: "message", T: KeyringSpec },
    { no: 11, name: "upgrades", kind: "message", T: UpgradesSpec },
    { no: 12, name: "rateLimiting", kind: "message", T: RateLimitingSpec },
    { no: 13, name: "auth", kind: "message", T: AuthSpec },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): GatewayConfigSpec {
    return new GatewayConfigSpec().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): GatewayConfigSpec {
    return new GatewayConfigSpec().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): GatewayConfigSpec {
    return new GatewayConfigSpec().fromJsonString(jsonString, options);
  }

  static equals(a: GatewayConfigSpec | PlainMessage<GatewayConfigSpec> | undefined, b: GatewayConfigSpec | PlainMessage<GatewayConfigSpec> | undefined): boolean {
    return proto3.util.equals(GatewayConfigSpec, a, b);
  }
}

/**
 * @generated from message config.v1.ServerSpec
 */
export class ServerSpec extends Message<ServerSpec> {
  /**
   * Address and port to serve the gateway's internal http server on.
   *
   * @generated from field: optional string httpListenAddress = 1;
   */
  httpListenAddress?: string;

  /**
   * Address and port to serve the gateway's external grpc server on.
   *
   * @generated from field: optional string grpcListenAddress = 2;
   */
  grpcListenAddress?: string;

  /**
   * The advertise address for the server.
   *
   * @generated from field: optional string advertiseAddress = 3;
   */
  advertiseAddress?: string;

  constructor(data?: PartialMessage<ServerSpec>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "config.v1.ServerSpec";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "httpListenAddress", kind: "scalar", T: 9 /* ScalarType.STRING */, opt: true },
    { no: 2, name: "grpcListenAddress", kind: "scalar", T: 9 /* ScalarType.STRING */, opt: true },
    { no: 3, name: "advertiseAddress", kind: "scalar", T: 9 /* ScalarType.STRING */, opt: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): ServerSpec {
    return new ServerSpec().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): ServerSpec {
    return new ServerSpec().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): ServerSpec {
    return new ServerSpec().fromJsonString(jsonString, options);
  }

  static equals(a: ServerSpec | PlainMessage<ServerSpec> | undefined, b: ServerSpec | PlainMessage<ServerSpec> | undefined): boolean {
    return proto3.util.equals(ServerSpec, a, b);
  }
}

/**
 * @generated from message config.v1.ManagementServerSpec
 */
export class ManagementServerSpec extends Message<ManagementServerSpec> {
  /**
   * Address and port to serve the management http server on.
   *
   * @generated from field: optional string httpListenAddress = 1;
   */
  httpListenAddress?: string;

  /**
   * Address and port to serve the management grpc server on.
   *
   * @generated from field: optional string grpcListenAddress = 2;
   */
  grpcListenAddress?: string;

  /**
   * The advertise address for the management server.
   * This is the address at which other gateway instances will be able to reach
   * this management server.
   *
   * @generated from field: optional string advertiseAddress = 3;
   */
  advertiseAddress?: string;

  constructor(data?: PartialMessage<ManagementServerSpec>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "config.v1.ManagementServerSpec";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "httpListenAddress", kind: "scalar", T: 9 /* ScalarType.STRING */, opt: true },
    { no: 2, name: "grpcListenAddress", kind: "scalar", T: 9 /* ScalarType.STRING */, opt: true },
    { no: 3, name: "advertiseAddress", kind: "scalar", T: 9 /* ScalarType.STRING */, opt: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): ManagementServerSpec {
    return new ManagementServerSpec().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): ManagementServerSpec {
    return new ManagementServerSpec().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): ManagementServerSpec {
    return new ManagementServerSpec().fromJsonString(jsonString, options);
  }

  static equals(a: ManagementServerSpec | PlainMessage<ManagementServerSpec> | undefined, b: ManagementServerSpec | PlainMessage<ManagementServerSpec> | undefined): boolean {
    return proto3.util.equals(ManagementServerSpec, a, b);
  }
}

/**
 * @generated from message config.v1.RelayServerSpec
 */
export class RelayServerSpec extends Message<RelayServerSpec> {
  /**
   * Address and port to serve the relay grpc server on.
   *
   * @generated from field: optional string grpcListenAddress = 4;
   */
  grpcListenAddress?: string;

  /**
   * The advertise address for the relay server.
   * This is the address at which other gateway instances will be able to reach
   * this relay server. Configured automatically by the manager if not set.
   *
   * @generated from field: optional string advertiseAddress = 5;
   */
  advertiseAddress?: string;

  constructor(data?: PartialMessage<RelayServerSpec>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "config.v1.RelayServerSpec";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 4, name: "grpcListenAddress", kind: "scalar", T: 9 /* ScalarType.STRING */, opt: true },
    { no: 5, name: "advertiseAddress", kind: "scalar", T: 9 /* ScalarType.STRING */, opt: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): RelayServerSpec {
    return new RelayServerSpec().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): RelayServerSpec {
    return new RelayServerSpec().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): RelayServerSpec {
    return new RelayServerSpec().fromJsonString(jsonString, options);
  }

  static equals(a: RelayServerSpec | PlainMessage<RelayServerSpec> | undefined, b: RelayServerSpec | PlainMessage<RelayServerSpec> | undefined): boolean {
    return proto3.util.equals(RelayServerSpec, a, b);
  }
}

/**
 * @generated from message config.v1.HealthServerSpec
 */
export class HealthServerSpec extends Message<HealthServerSpec> {
  /**
   * Address and port to serve the gateway's internal health/metrics/profiling http server on.
   *
   * @generated from field: optional string httpListenAddress = 1;
   */
  httpListenAddress?: string;

  constructor(data?: PartialMessage<HealthServerSpec>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "config.v1.HealthServerSpec";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "httpListenAddress", kind: "scalar", T: 9 /* ScalarType.STRING */, opt: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): HealthServerSpec {
    return new HealthServerSpec().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): HealthServerSpec {
    return new HealthServerSpec().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): HealthServerSpec {
    return new HealthServerSpec().fromJsonString(jsonString, options);
  }

  static equals(a: HealthServerSpec | PlainMessage<HealthServerSpec> | undefined, b: HealthServerSpec | PlainMessage<HealthServerSpec> | undefined): boolean {
    return proto3.util.equals(HealthServerSpec, a, b);
  }
}

/**
 * @generated from message config.v1.DashboardServerSpec
 */
export class DashboardServerSpec extends Message<DashboardServerSpec> {
  /**
   * Address and port to serve the web dashboard on.
   *
   * @generated from field: optional string httpListenAddress = 1;
   */
  httpListenAddress?: string;

  /**
   * The advertise address for the dashboard server.
   *
   * @generated from field: optional string advertiseAddress = 2;
   */
  advertiseAddress?: string;

  /**
   * The hostname at which the dashboard is expected to be reachable.
   * This is required when using OpenID Connect authentication.
   *
   * @generated from field: optional string hostname = 3;
   */
  hostname?: string;

  /**
   * List of trusted proxies for the dashboard's http server.
   *
   * @generated from field: repeated string trustedProxies = 4;
   */
  trustedProxies: string[] = [];

  /**
   * Optional certificate configuration. If not set, the dashboard will use
   * the same certificates as the gateway's internal http server.
   *
   * @generated from field: optional config.v1.CertsSpec webCerts = 5;
   */
  webCerts?: CertsSpec;

  constructor(data?: PartialMessage<DashboardServerSpec>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "config.v1.DashboardServerSpec";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "httpListenAddress", kind: "scalar", T: 9 /* ScalarType.STRING */, opt: true },
    { no: 2, name: "advertiseAddress", kind: "scalar", T: 9 /* ScalarType.STRING */, opt: true },
    { no: 3, name: "hostname", kind: "scalar", T: 9 /* ScalarType.STRING */, opt: true },
    { no: 4, name: "trustedProxies", kind: "scalar", T: 9 /* ScalarType.STRING */, repeated: true },
    { no: 5, name: "webCerts", kind: "message", T: CertsSpec, opt: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): DashboardServerSpec {
    return new DashboardServerSpec().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): DashboardServerSpec {
    return new DashboardServerSpec().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): DashboardServerSpec {
    return new DashboardServerSpec().fromJsonString(jsonString, options);
  }

  static equals(a: DashboardServerSpec | PlainMessage<DashboardServerSpec> | undefined, b: DashboardServerSpec | PlainMessage<DashboardServerSpec> | undefined): boolean {
    return proto3.util.equals(DashboardServerSpec, a, b);
  }
}

/**
 * @generated from message config.v1.StorageSpec
 */
export class StorageSpec extends Message<StorageSpec> {
  /**
   * Key-value storage backend.
   *
   * @generated from field: optional config.v1.StorageBackend backend = 1;
   */
  backend?: StorageBackend;

  /**
   * @generated from field: config.v1.EtcdSpec etcd = 2;
   */
  etcd?: EtcdSpec;

  /**
   * @generated from field: config.v1.JetStreamSpec jetStream = 3;
   */
  jetStream?: JetStreamSpec;

  constructor(data?: PartialMessage<StorageSpec>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "config.v1.StorageSpec";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "backend", kind: "enum", T: proto3.getEnumType(StorageBackend), opt: true },
    { no: 2, name: "etcd", kind: "message", T: EtcdSpec },
    { no: 3, name: "jetStream", kind: "message", T: JetStreamSpec },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): StorageSpec {
    return new StorageSpec().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): StorageSpec {
    return new StorageSpec().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): StorageSpec {
    return new StorageSpec().fromJsonString(jsonString, options);
  }

  static equals(a: StorageSpec | PlainMessage<StorageSpec> | undefined, b: StorageSpec | PlainMessage<StorageSpec> | undefined): boolean {
    return proto3.util.equals(StorageSpec, a, b);
  }
}

/**
 * @generated from message config.v1.EtcdSpec
 */
export class EtcdSpec extends Message<EtcdSpec> {
  /**
   * Etcd server endpoints.
   *
   * @generated from field: repeated string endpoints = 1;
   */
  endpoints: string[] = [];

  /**
   * Etcd client certificate configuration.
   *
   * @generated from field: config.v1.MTLSSpec certs = 2;
   */
  certs?: MTLSSpec;

  constructor(data?: PartialMessage<EtcdSpec>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "config.v1.EtcdSpec";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "endpoints", kind: "scalar", T: 9 /* ScalarType.STRING */, repeated: true },
    { no: 2, name: "certs", kind: "message", T: MTLSSpec },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): EtcdSpec {
    return new EtcdSpec().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): EtcdSpec {
    return new EtcdSpec().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): EtcdSpec {
    return new EtcdSpec().fromJsonString(jsonString, options);
  }

  static equals(a: EtcdSpec | PlainMessage<EtcdSpec> | undefined, b: EtcdSpec | PlainMessage<EtcdSpec> | undefined): boolean {
    return proto3.util.equals(EtcdSpec, a, b);
  }
}

/**
 * @generated from message config.v1.MTLSSpec
 */
export class MTLSSpec extends Message<MTLSSpec> {
  /**
   * Path to the server CA certificate. Mutually exclusive with serverCAData.
   *
   * @generated from field: optional string serverCA = 1;
   */
  serverCA?: string;

  /**
   * PEM encoded server CA certificate data. Mutually exclusive with serverCA.
   *
   * @generated from field: optional string serverCAData = 2;
   */
  serverCAData?: string;

  /**
   * Path to the client CA certificate (not needed in all cases). Mutually exclusive with clientCAData.
   *
   * @generated from field: optional string clientCA = 3;
   */
  clientCA?: string;

  /**
   * PEM encoded client CA certificate data. Mutually exclusive with clientCA.
   *
   * @generated from field: optional string clientCAData = 4;
   */
  clientCAData?: string;

  /**
   * Path to the certificate used for client-cert auth. Mutually exclusive with clientCertData.
   *
   * @generated from field: optional string clientCert = 5;
   */
  clientCert?: string;

  /**
   * PEM encoded client certificate data. Mutually exclusive with clientCert.
   *
   * @generated from field: optional string clientCertData = 6;
   */
  clientCertData?: string;

  /**
   * Path to the private key used for client-cert auth. Mutually exclusive with clientKeyData.
   *
   * @generated from field: optional string clientKey = 7;
   */
  clientKey?: string;

  /**
   * PEM encoded client key data. Mutually exclusive with clientKey.
   *
   * @generated from field: optional string clientKeyData = 8;
   */
  clientKeyData?: string;

  constructor(data?: PartialMessage<MTLSSpec>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "config.v1.MTLSSpec";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "serverCA", kind: "scalar", T: 9 /* ScalarType.STRING */, opt: true },
    { no: 2, name: "serverCAData", kind: "scalar", T: 9 /* ScalarType.STRING */, opt: true },
    { no: 3, name: "clientCA", kind: "scalar", T: 9 /* ScalarType.STRING */, opt: true },
    { no: 4, name: "clientCAData", kind: "scalar", T: 9 /* ScalarType.STRING */, opt: true },
    { no: 5, name: "clientCert", kind: "scalar", T: 9 /* ScalarType.STRING */, opt: true },
    { no: 6, name: "clientCertData", kind: "scalar", T: 9 /* ScalarType.STRING */, opt: true },
    { no: 7, name: "clientKey", kind: "scalar", T: 9 /* ScalarType.STRING */, opt: true },
    { no: 8, name: "clientKeyData", kind: "scalar", T: 9 /* ScalarType.STRING */, opt: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): MTLSSpec {
    return new MTLSSpec().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): MTLSSpec {
    return new MTLSSpec().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): MTLSSpec {
    return new MTLSSpec().fromJsonString(jsonString, options);
  }

  static equals(a: MTLSSpec | PlainMessage<MTLSSpec> | undefined, b: MTLSSpec | PlainMessage<MTLSSpec> | undefined): boolean {
    return proto3.util.equals(MTLSSpec, a, b);
  }
}

/**
 * @generated from message config.v1.JetStreamSpec
 */
export class JetStreamSpec extends Message<JetStreamSpec> {
  /**
   * Jetstream server endpoint.
   *
   * @generated from field: optional string endpoint = 1;
   */
  endpoint?: string;

  /**
   * Path to the Jetstream nkey seed.
   *
   * @generated from field: optional string nkeySeedPath = 2;
   */
  nkeySeedPath?: string;

  constructor(data?: PartialMessage<JetStreamSpec>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "config.v1.JetStreamSpec";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "endpoint", kind: "scalar", T: 9 /* ScalarType.STRING */, opt: true },
    { no: 2, name: "nkeySeedPath", kind: "scalar", T: 9 /* ScalarType.STRING */, opt: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): JetStreamSpec {
    return new JetStreamSpec().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): JetStreamSpec {
    return new JetStreamSpec().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): JetStreamSpec {
    return new JetStreamSpec().fromJsonString(jsonString, options);
  }

  static equals(a: JetStreamSpec | PlainMessage<JetStreamSpec> | undefined, b: JetStreamSpec | PlainMessage<JetStreamSpec> | undefined): boolean {
    return proto3.util.equals(JetStreamSpec, a, b);
  }
}

/**
 * @generated from message config.v1.CertsSpec
 */
export class CertsSpec extends Message<CertsSpec> {
  /**
   * Path to a PEM encoded CA certificate file. Mutually exclusive with caCertData.
   *
   * @generated from field: optional string caCert = 1;
   */
  caCert?: string;

  /**
   * PEM encoded CA certificate data. Mutually exclusive with caCert.
   *
   * @generated from field: optional string caCertData = 2;
   */
  caCertData?: string;

  /**
   * Path to a PEM encoded server certificate file. Mutually exclusive with servingCertData.
   *
   * @generated from field: optional string servingCert = 3;
   */
  servingCert?: string;

  /**
   * PEM encoded server certificate data. Mutually exclusive with servingCert.
   *
   * @generated from field: optional string servingCertData = 4;
   */
  servingCertData?: string;

  /**
   * Path to a PEM encoded server key file. Mutually exclusive with servingKeyData.
   *
   * @generated from field: optional string servingKey = 5;
   */
  servingKey?: string;

  /**
   * String containing PEM encoded server key data. Mutually exclusive with servingKey.
   *
   * @generated from field: optional string servingKeyData = 6;
   */
  servingKeyData?: string;

  constructor(data?: PartialMessage<CertsSpec>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "config.v1.CertsSpec";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "caCert", kind: "scalar", T: 9 /* ScalarType.STRING */, opt: true },
    { no: 2, name: "caCertData", kind: "scalar", T: 9 /* ScalarType.STRING */, opt: true },
    { no: 3, name: "servingCert", kind: "scalar", T: 9 /* ScalarType.STRING */, opt: true },
    { no: 4, name: "servingCertData", kind: "scalar", T: 9 /* ScalarType.STRING */, opt: true },
    { no: 5, name: "servingKey", kind: "scalar", T: 9 /* ScalarType.STRING */, opt: true },
    { no: 6, name: "servingKeyData", kind: "scalar", T: 9 /* ScalarType.STRING */, opt: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): CertsSpec {
    return new CertsSpec().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): CertsSpec {
    return new CertsSpec().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): CertsSpec {
    return new CertsSpec().fromJsonString(jsonString, options);
  }

  static equals(a: CertsSpec | PlainMessage<CertsSpec> | undefined, b: CertsSpec | PlainMessage<CertsSpec> | undefined): boolean {
    return proto3.util.equals(CertsSpec, a, b);
  }
}

/**
 * @generated from message config.v1.PluginsSpec
 */
export class PluginsSpec extends Message<PluginsSpec> {
  /**
   * Directory to search for plugin binaries.
   *
   * @generated from field: optional string dir = 1;
   */
  dir?: string;

  /**
   * Optional set of filters which can be used to prevent specific plugins
   * from being loaded.
   *
   * @generated from field: config.v1.PluginFilters filters = 2;
   */
  filters?: PluginFilters;

  /**
   * Plugin cache configuration.
   *
   * @generated from field: config.v1.CacheSpec cache = 4;
   */
  cache?: CacheSpec;

  constructor(data?: PartialMessage<PluginsSpec>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "config.v1.PluginsSpec";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "dir", kind: "scalar", T: 9 /* ScalarType.STRING */, opt: true },
    { no: 2, name: "filters", kind: "message", T: PluginFilters },
    { no: 4, name: "cache", kind: "message", T: CacheSpec },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): PluginsSpec {
    return new PluginsSpec().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): PluginsSpec {
    return new PluginsSpec().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): PluginsSpec {
    return new PluginsSpec().fromJsonString(jsonString, options);
  }

  static equals(a: PluginsSpec | PlainMessage<PluginsSpec> | undefined, b: PluginsSpec | PlainMessage<PluginsSpec> | undefined): boolean {
    return proto3.util.equals(PluginsSpec, a, b);
  }
}

/**
 * @generated from message config.v1.PluginFilters
 */
export class PluginFilters extends Message<PluginFilters> {
  /**
   * List of plugin go module paths not to load.
   *
   * @generated from field: repeated string exclude = 1;
   */
  exclude: string[] = [];

  constructor(data?: PartialMessage<PluginFilters>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "config.v1.PluginFilters";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "exclude", kind: "scalar", T: 9 /* ScalarType.STRING */, repeated: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): PluginFilters {
    return new PluginFilters().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): PluginFilters {
    return new PluginFilters().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): PluginFilters {
    return new PluginFilters().fromJsonString(jsonString, options);
  }

  static equals(a: PluginFilters | PlainMessage<PluginFilters> | undefined, b: PluginFilters | PlainMessage<PluginFilters> | undefined): boolean {
    return proto3.util.equals(PluginFilters, a, b);
  }
}

/**
 * @generated from message config.v1.CacheSpec
 */
export class CacheSpec extends Message<CacheSpec> {
  /**
   * Cache backend to use for storing plugin binaries and patches.
   *
   * @generated from field: optional config.v1.CacheBackend backend = 2;
   */
  backend?: CacheBackend;

  /**
   * Filesystem cache configuration. Required if backend is Filesystem.
   *
   * @generated from field: config.v1.FilesystemCacheSpec filesystem = 3;
   */
  filesystem?: FilesystemCacheSpec;

  constructor(data?: PartialMessage<CacheSpec>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "config.v1.CacheSpec";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 2, name: "backend", kind: "enum", T: proto3.getEnumType(CacheBackend), opt: true },
    { no: 3, name: "filesystem", kind: "message", T: FilesystemCacheSpec },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): CacheSpec {
    return new CacheSpec().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): CacheSpec {
    return new CacheSpec().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): CacheSpec {
    return new CacheSpec().fromJsonString(jsonString, options);
  }

  static equals(a: CacheSpec | PlainMessage<CacheSpec> | undefined, b: CacheSpec | PlainMessage<CacheSpec> | undefined): boolean {
    return proto3.util.equals(CacheSpec, a, b);
  }
}

/**
 * @generated from message config.v1.FilesystemCacheSpec
 */
export class FilesystemCacheSpec extends Message<FilesystemCacheSpec> {
  /**
   * Directory to store plugin binaries and patches in.
   *
   * @generated from field: optional string dir = 1;
   */
  dir?: string;

  constructor(data?: PartialMessage<FilesystemCacheSpec>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "config.v1.FilesystemCacheSpec";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "dir", kind: "scalar", T: 9 /* ScalarType.STRING */, opt: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): FilesystemCacheSpec {
    return new FilesystemCacheSpec().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): FilesystemCacheSpec {
    return new FilesystemCacheSpec().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): FilesystemCacheSpec {
    return new FilesystemCacheSpec().fromJsonString(jsonString, options);
  }

  static equals(a: FilesystemCacheSpec | PlainMessage<FilesystemCacheSpec> | undefined, b: FilesystemCacheSpec | PlainMessage<FilesystemCacheSpec> | undefined): boolean {
    return proto3.util.equals(FilesystemCacheSpec, a, b);
  }
}

/**
 * @generated from message config.v1.KeyringSpec
 */
export class KeyringSpec extends Message<KeyringSpec> {
  /**
   * Directories to search for files containing runtime keys.
   * All files in these directories will be loaded into the keyring on
   * startup. Keys loaded in this way will not be persisted.
   *
   * @generated from field: repeated string runtimeKeyDirs = 1;
   */
  runtimeKeyDirs: string[] = [];

  constructor(data?: PartialMessage<KeyringSpec>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "config.v1.KeyringSpec";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "runtimeKeyDirs", kind: "scalar", T: 9 /* ScalarType.STRING */, repeated: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): KeyringSpec {
    return new KeyringSpec().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): KeyringSpec {
    return new KeyringSpec().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): KeyringSpec {
    return new KeyringSpec().fromJsonString(jsonString, options);
  }

  static equals(a: KeyringSpec | PlainMessage<KeyringSpec> | undefined, b: KeyringSpec | PlainMessage<KeyringSpec> | undefined): boolean {
    return proto3.util.equals(KeyringSpec, a, b);
  }
}

/**
 * @generated from message config.v1.UpgradesSpec
 */
export class UpgradesSpec extends Message<UpgradesSpec> {
  /**
   * @generated from field: optional config.v1.AgentUpgradesSpec agents = 1;
   */
  agents?: AgentUpgradesSpec;

  /**
   * @generated from field: optional config.v1.PluginUpgradesSpec plugins = 2;
   */
  plugins?: PluginUpgradesSpec;

  constructor(data?: PartialMessage<UpgradesSpec>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "config.v1.UpgradesSpec";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "agents", kind: "message", T: AgentUpgradesSpec, opt: true },
    { no: 2, name: "plugins", kind: "message", T: PluginUpgradesSpec, opt: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): UpgradesSpec {
    return new UpgradesSpec().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): UpgradesSpec {
    return new UpgradesSpec().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): UpgradesSpec {
    return new UpgradesSpec().fromJsonString(jsonString, options);
  }

  static equals(a: UpgradesSpec | PlainMessage<UpgradesSpec> | undefined, b: UpgradesSpec | PlainMessage<UpgradesSpec> | undefined): boolean {
    return proto3.util.equals(UpgradesSpec, a, b);
  }
}

/**
 * @generated from message config.v1.AgentUpgradesSpec
 */
export class AgentUpgradesSpec extends Message<AgentUpgradesSpec> {
  /**
   * Kubernetes agent upgrade driver configuration.
   *
   * @generated from field: config.v1.KubernetesAgentUpgradeSpec kubernetes = 2;
   */
  kubernetes?: KubernetesAgentUpgradeSpec;

  constructor(data?: PartialMessage<AgentUpgradesSpec>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "config.v1.AgentUpgradesSpec";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 2, name: "kubernetes", kind: "message", T: KubernetesAgentUpgradeSpec },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): AgentUpgradesSpec {
    return new AgentUpgradesSpec().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): AgentUpgradesSpec {
    return new AgentUpgradesSpec().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): AgentUpgradesSpec {
    return new AgentUpgradesSpec().fromJsonString(jsonString, options);
  }

  static equals(a: AgentUpgradesSpec | PlainMessage<AgentUpgradesSpec> | undefined, b: AgentUpgradesSpec | PlainMessage<AgentUpgradesSpec> | undefined): boolean {
    return proto3.util.equals(AgentUpgradesSpec, a, b);
  }
}

/**
 * @generated from message config.v1.PluginUpgradesSpec
 */
export class PluginUpgradesSpec extends Message<PluginUpgradesSpec> {
  /**
   * Binary plugin upgrade driver configuration.
   *
   * @generated from field: config.v1.BinaryPluginUpgradeSpec binary = 2;
   */
  binary?: BinaryPluginUpgradeSpec;

  constructor(data?: PartialMessage<PluginUpgradesSpec>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "config.v1.PluginUpgradesSpec";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 2, name: "binary", kind: "message", T: BinaryPluginUpgradeSpec },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): PluginUpgradesSpec {
    return new PluginUpgradesSpec().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): PluginUpgradesSpec {
    return new PluginUpgradesSpec().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): PluginUpgradesSpec {
    return new PluginUpgradesSpec().fromJsonString(jsonString, options);
  }

  static equals(a: PluginUpgradesSpec | PlainMessage<PluginUpgradesSpec> | undefined, b: PluginUpgradesSpec | PlainMessage<PluginUpgradesSpec> | undefined): boolean {
    return proto3.util.equals(PluginUpgradesSpec, a, b);
  }
}

/**
 * @generated from message config.v1.BinaryPluginUpgradeSpec
 */
export class BinaryPluginUpgradeSpec extends Message<BinaryPluginUpgradeSpec> {
  /**
   * Patch engine to use for calculating plugin patches.
   *
   * @generated from field: optional config.v1.PatchEngine patchEngine = 1;
   */
  patchEngine?: PatchEngine;

  constructor(data?: PartialMessage<BinaryPluginUpgradeSpec>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "config.v1.BinaryPluginUpgradeSpec";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "patchEngine", kind: "enum", T: proto3.getEnumType(PatchEngine), opt: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): BinaryPluginUpgradeSpec {
    return new BinaryPluginUpgradeSpec().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): BinaryPluginUpgradeSpec {
    return new BinaryPluginUpgradeSpec().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): BinaryPluginUpgradeSpec {
    return new BinaryPluginUpgradeSpec().fromJsonString(jsonString, options);
  }

  static equals(a: BinaryPluginUpgradeSpec | PlainMessage<BinaryPluginUpgradeSpec> | undefined, b: BinaryPluginUpgradeSpec | PlainMessage<BinaryPluginUpgradeSpec> | undefined): boolean {
    return proto3.util.equals(BinaryPluginUpgradeSpec, a, b);
  }
}

/**
 * @generated from message config.v1.KubernetesAgentUpgradeSpec
 */
export class KubernetesAgentUpgradeSpec extends Message<KubernetesAgentUpgradeSpec> {
  /**
   * Agent image resolver to use.
   *
   * @generated from field: optional config.v1.KubernetesAgentUpgradeSpec.ImageResolver imageResolver = 1;
   */
  imageResolver?: KubernetesAgentUpgradeSpec_ImageResolver;

  constructor(data?: PartialMessage<KubernetesAgentUpgradeSpec>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "config.v1.KubernetesAgentUpgradeSpec";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "imageResolver", kind: "enum", T: proto3.getEnumType(KubernetesAgentUpgradeSpec_ImageResolver), opt: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): KubernetesAgentUpgradeSpec {
    return new KubernetesAgentUpgradeSpec().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): KubernetesAgentUpgradeSpec {
    return new KubernetesAgentUpgradeSpec().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): KubernetesAgentUpgradeSpec {
    return new KubernetesAgentUpgradeSpec().fromJsonString(jsonString, options);
  }

  static equals(a: KubernetesAgentUpgradeSpec | PlainMessage<KubernetesAgentUpgradeSpec> | undefined, b: KubernetesAgentUpgradeSpec | PlainMessage<KubernetesAgentUpgradeSpec> | undefined): boolean {
    return proto3.util.equals(KubernetesAgentUpgradeSpec, a, b);
  }
}

/**
 * @generated from enum config.v1.KubernetesAgentUpgradeSpec.ImageResolver
 */
export enum KubernetesAgentUpgradeSpec_ImageResolver {
  /**
   * @generated from enum value: Noop = 0;
   */
  Noop = 0,

  /**
   * @generated from enum value: Kubernetes = 1;
   */
  Kubernetes = 1,
}
// Retrieve enum metadata with: proto3.getEnumType(KubernetesAgentUpgradeSpec_ImageResolver)
proto3.util.setEnumType(KubernetesAgentUpgradeSpec_ImageResolver, "config.v1.KubernetesAgentUpgradeSpec.ImageResolver", [
  { no: 0, name: "Noop" },
  { no: 1, name: "Kubernetes" },
]);

/**
 * @generated from message config.v1.RateLimitingSpec
 */
export class RateLimitingSpec extends Message<RateLimitingSpec> {
  /**
   * Base event rate used for rate limiting agent connection attempts.
   *
   * @generated from field: optional double rate = 1;
   */
  rate?: number;

  /**
   * Burst event rate.
   *
   * @generated from field: optional int32 burst = 2;
   */
  burst?: number;

  constructor(data?: PartialMessage<RateLimitingSpec>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "config.v1.RateLimitingSpec";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "rate", kind: "scalar", T: 1 /* ScalarType.DOUBLE */, opt: true },
    { no: 2, name: "burst", kind: "scalar", T: 5 /* ScalarType.INT32 */, opt: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): RateLimitingSpec {
    return new RateLimitingSpec().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): RateLimitingSpec {
    return new RateLimitingSpec().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): RateLimitingSpec {
    return new RateLimitingSpec().fromJsonString(jsonString, options);
  }

  static equals(a: RateLimitingSpec | PlainMessage<RateLimitingSpec> | undefined, b: RateLimitingSpec | PlainMessage<RateLimitingSpec> | undefined): boolean {
    return proto3.util.equals(RateLimitingSpec, a, b);
  }
}

/**
 * @generated from message config.v1.AuthSpec
 */
export class AuthSpec extends Message<AuthSpec> {
  /**
   * Auth backend to use.
   *
   * @generated from field: optional config.v1.AuthSpec.Backend backend = 1;
   */
  backend?: AuthSpec_Backend;

  /**
   * Basic auth using a username and password.
   *
   * @generated from field: config.v1.BasicAuthSpec basic = 3;
   */
  basic?: BasicAuthSpec;

  /**
   * OpenID Connect auth.
   *
   * @generated from field: config.v1.OpenIDAuthSpec openid = 2;
   */
  openid?: OpenIDAuthSpec;

  constructor(data?: PartialMessage<AuthSpec>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "config.v1.AuthSpec";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "backend", kind: "enum", T: proto3.getEnumType(AuthSpec_Backend), opt: true },
    { no: 3, name: "basic", kind: "message", T: BasicAuthSpec },
    { no: 2, name: "openid", kind: "message", T: OpenIDAuthSpec },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): AuthSpec {
    return new AuthSpec().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): AuthSpec {
    return new AuthSpec().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): AuthSpec {
    return new AuthSpec().fromJsonString(jsonString, options);
  }

  static equals(a: AuthSpec | PlainMessage<AuthSpec> | undefined, b: AuthSpec | PlainMessage<AuthSpec> | undefined): boolean {
    return proto3.util.equals(AuthSpec, a, b);
  }
}

/**
 * @generated from enum config.v1.AuthSpec.Backend
 */
export enum AuthSpec_Backend {
  /**
   * @generated from enum value: Basic = 0;
   */
  Basic = 0,

  /**
   * @generated from enum value: OpenID = 1;
   */
  OpenID = 1,
}
// Retrieve enum metadata with: proto3.getEnumType(AuthSpec_Backend)
proto3.util.setEnumType(AuthSpec_Backend, "config.v1.AuthSpec.Backend", [
  { no: 0, name: "Basic" },
  { no: 1, name: "OpenID" },
]);

/**
 * @generated from message config.v1.OpenIDAuthSpec
 */
export class OpenIDAuthSpec extends Message<OpenIDAuthSpec> {
  /**
   * The OP's Issuer identifier. This must exactly match the issuer URL
   * obtained from the discovery endpoint, and will match the `iss' claim
   * in the ID Tokens issued by the OP.
   * The discovery endpoint consists of this URL concatenated with the
   * exact string `/.well-known/openid-configuration'.
   *
   * @generated from field: optional string issuer = 1;
   */
  issuer?: string;

  /**
   * Optional PEM-encoded CA certificate data for the issuer.
   *
   * @generated from field: optional string caCertData = 2;
   */
  caCertData?: string;

  /**
   * The RP's client ID.
   *
   * @generated from field: optional string clientId = 3;
   */
  clientId?: string;

  /**
   * The RP's client secret.
   *
   * @generated from field: optional string clientSecret = 4;
   */
  clientSecret?: string;

  /**
   * IdentifyingClaim is the claim that will be used to identify the user
   * (e.g. "sub", "email", etc). Defaults to "sub".
   *
   * @generated from field: optional string identifyingClaim = 5;
   */
  identifyingClaim?: string;

  /**
   * Scope specifies optional requested permissions.
   *
   * @generated from field: repeated string scopes = 6;
   */
  scopes: string[] = [];

  constructor(data?: PartialMessage<OpenIDAuthSpec>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "config.v1.OpenIDAuthSpec";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "issuer", kind: "scalar", T: 9 /* ScalarType.STRING */, opt: true },
    { no: 2, name: "caCertData", kind: "scalar", T: 9 /* ScalarType.STRING */, opt: true },
    { no: 3, name: "clientId", kind: "scalar", T: 9 /* ScalarType.STRING */, opt: true },
    { no: 4, name: "clientSecret", kind: "scalar", T: 9 /* ScalarType.STRING */, opt: true },
    { no: 5, name: "identifyingClaim", kind: "scalar", T: 9 /* ScalarType.STRING */, opt: true },
    { no: 6, name: "scopes", kind: "scalar", T: 9 /* ScalarType.STRING */, repeated: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): OpenIDAuthSpec {
    return new OpenIDAuthSpec().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): OpenIDAuthSpec {
    return new OpenIDAuthSpec().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): OpenIDAuthSpec {
    return new OpenIDAuthSpec().fromJsonString(jsonString, options);
  }

  static equals(a: OpenIDAuthSpec | PlainMessage<OpenIDAuthSpec> | undefined, b: OpenIDAuthSpec | PlainMessage<OpenIDAuthSpec> | undefined): boolean {
    return proto3.util.equals(OpenIDAuthSpec, a, b);
  }
}

/**
 * @generated from message config.v1.BasicAuthSpec
 */
export class BasicAuthSpec extends Message<BasicAuthSpec> {
  constructor(data?: PartialMessage<BasicAuthSpec>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "config.v1.BasicAuthSpec";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): BasicAuthSpec {
    return new BasicAuthSpec().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): BasicAuthSpec {
    return new BasicAuthSpec().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): BasicAuthSpec {
    return new BasicAuthSpec().fromJsonString(jsonString, options);
  }

  static equals(a: BasicAuthSpec | PlainMessage<BasicAuthSpec> | undefined, b: BasicAuthSpec | PlainMessage<BasicAuthSpec> | undefined): boolean {
    return proto3.util.equals(BasicAuthSpec, a, b);
  }
}


// Code generated by internal/codegen. You may edit parts of this file.
// Field numbers and custom options will be preserved for matching field names.
// All other modifications will be lost.

// @generated by protoc-gen-es v1.10.1 with parameter "target=ts,import_extension=none,ts_nocheck=false"
// @generated from file github.com/aity-cloud/monty/internal/cortex/config/querier/querier.proto (package querier, syntax proto3)
/* eslint-disable */

import type { BinaryReadOptions, FieldList, JsonReadOptions, JsonValue, PartialMessage, PlainMessage } from "@bufbuild/protobuf";
import { Duration, Message, proto3 } from "@bufbuild/protobuf";

/**
 * @generated from message querier.Config
 */
export class Config extends Message<Config> {
  /**
   * The maximum number of concurrent queries.
   *
   * @generated from field: optional int32 max_concurrent = 1;
   */
  maxConcurrent?: number;

  /**
   * The timeout for a query.
   *
   * @generated from field: google.protobuf.Duration timeout = 2;
   */
  timeout?: Duration;

  /**
   * Use LabelNames ingester RPCs with match params.
   *
   * @generated from field: optional bool ingester_label_names_with_matchers = 4;
   */
  ingesterLabelNamesWithMatchers?: boolean;

  /**
   * Deprecated (This feature will be always on after v1.18): Use streaming RPCs for metadata APIs from ingester.
   *
   * @generated from field: optional bool ingester_metadata_streaming = 6;
   */
  ingesterMetadataStreaming?: boolean;

  /**
   * Maximum number of samples a single query can load into memory.
   *
   * @generated from field: optional int32 max_samples = 7;
   */
  maxSamples?: number;

  /**
   * The time after which a metric should be queried from storage and not just ingesters. 0 means all queries are sent to store. When running the blocks storage, if this option is enabled, the time range of the query sent to the store will be manipulated to ensure the query end is not more recent than 'now - query-store-after'.
   *
   * @generated from field: google.protobuf.Duration query_store_after = 11;
   */
  queryStoreAfter?: Duration;

  /**
   * When distributor's sharding strategy is shuffle-sharding and this setting is > 0, queriers fetch in-memory series from the minimum set of required ingesters, selecting only ingesters which may have received series since 'now - lookback period'. The lookback period should be greater or equal than the configured 'query store after' and 'query ingesters within'. If this setting is 0, queriers always query all ingesters (ingesters shuffle sharding on read path is disabled).
   *
   * @generated from field: google.protobuf.Duration shuffle_sharding_ingesters_lookback_period = 15;
   */
  shuffleShardingIngestersLookbackPeriod?: Duration;

  /**
   * Experimental. Use Thanos promql engine https://github.com/thanos-io/promql-engine rather than the Prometheus promql engine.
   *
   * @generated from field: optional bool thanos_engine = 16;
   */
  thanosEngine?: boolean;

  /**
   * [Experimental] If true, experimental promQL functions are enabled.
   *
   * @generated from field: optional bool enable_promql_experimental_functions = 19;
   */
  enablePromqlExperimentalFunctions?: boolean;

  /**
   * Maximum lookback beyond which queries are not sent to ingester. 0 means all queries are sent to ingester.
   *
   * @generated from field: google.protobuf.Duration query_ingesters_within = 20;
   */
  queryIngestersWithin?: Duration;

  /**
   * Enable returning samples stats per steps in query response.
   *
   * @generated from field: optional bool per_step_stats_enabled = 21;
   */
  perStepStatsEnabled?: boolean;

  /**
   * Use compression for metrics query API or instant and range query APIs. Supports 'gzip' and '' (disable compression)
   *
   * @generated from field: optional string response_compression = 22;
   */
  responseCompression?: string;

  /**
   * Maximum duration into the future you can query. 0 to disable.
   *
   * @generated from field: google.protobuf.Duration max_query_into_future = 23;
   */
  maxQueryIntoFuture?: Duration;

  /**
   * The default evaluation interval or step size for subqueries.
   *
   * @generated from field: google.protobuf.Duration default_evaluation_interval = 24;
   */
  defaultEvaluationInterval?: Duration;

  /**
   * Max number of steps allowed for every subquery expression in query. Number of steps is calculated using subquery range / step. A value > 0 enables it.
   *
   * @generated from field: optional int64 max_subquery_steps = 25;
   */
  maxSubquerySteps?: bigint;

  /**
   * Time since the last sample after which a time series is considered stale and ignored by expression evaluations.
   *
   * @generated from field: google.protobuf.Duration lookback_delta = 26;
   */
  lookbackDelta?: Duration;

  /**
   * If enabled, store gateway query stats will be logged using `info` log level.
   *
   * @generated from field: optional bool store_gateway_query_stats = 27;
   */
  storeGatewayQueryStats?: boolean;

  /**
   * The maximum number of times we attempt fetching missing blocks from different store-gateways. If no more store-gateways are left (ie. due to lower replication factor) than we'll end the retries earlier
   *
   * @generated from field: optional int32 store_gateway_consistency_check_max_attempts = 28;
   */
  storeGatewayConsistencyCheckMaxAttempts?: number;

  /**
   * If enabled, ignore max query length check at Querier select method. Users can choose to ignore it since the validation can be done before Querier evaluation like at Query Frontend or Ruler.
   *
   * @generated from field: optional bool ignore_max_query_length = 29;
   */
  ignoreMaxQueryLength?: boolean;

  constructor(data?: PartialMessage<Config>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "querier.Config";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "max_concurrent", kind: "scalar", T: 5 /* ScalarType.INT32 */, opt: true },
    { no: 2, name: "timeout", kind: "message", T: Duration },
    { no: 4, name: "ingester_label_names_with_matchers", kind: "scalar", T: 8 /* ScalarType.BOOL */, opt: true },
    { no: 6, name: "ingester_metadata_streaming", kind: "scalar", T: 8 /* ScalarType.BOOL */, opt: true },
    { no: 7, name: "max_samples", kind: "scalar", T: 5 /* ScalarType.INT32 */, opt: true },
    { no: 11, name: "query_store_after", kind: "message", T: Duration },
    { no: 15, name: "shuffle_sharding_ingesters_lookback_period", kind: "message", T: Duration },
    { no: 16, name: "thanos_engine", kind: "scalar", T: 8 /* ScalarType.BOOL */, opt: true },
    { no: 19, name: "enable_promql_experimental_functions", kind: "scalar", T: 8 /* ScalarType.BOOL */, opt: true },
    { no: 20, name: "query_ingesters_within", kind: "message", T: Duration },
    { no: 21, name: "per_step_stats_enabled", kind: "scalar", T: 8 /* ScalarType.BOOL */, opt: true },
    { no: 22, name: "response_compression", kind: "scalar", T: 9 /* ScalarType.STRING */, opt: true },
    { no: 23, name: "max_query_into_future", kind: "message", T: Duration },
    { no: 24, name: "default_evaluation_interval", kind: "message", T: Duration },
    { no: 25, name: "max_subquery_steps", kind: "scalar", T: 3 /* ScalarType.INT64 */, opt: true },
    { no: 26, name: "lookback_delta", kind: "message", T: Duration },
    { no: 27, name: "store_gateway_query_stats", kind: "scalar", T: 8 /* ScalarType.BOOL */, opt: true },
    { no: 28, name: "store_gateway_consistency_check_max_attempts", kind: "scalar", T: 5 /* ScalarType.INT32 */, opt: true },
    { no: 29, name: "ignore_max_query_length", kind: "scalar", T: 8 /* ScalarType.BOOL */, opt: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): Config {
    return new Config().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): Config {
    return new Config().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): Config {
    return new Config().fromJsonString(jsonString, options);
  }

  static equals(a: Config | PlainMessage<Config> | undefined, b: Config | PlainMessage<Config> | undefined): boolean {
    return proto3.util.equals(Config, a, b);
  }
}


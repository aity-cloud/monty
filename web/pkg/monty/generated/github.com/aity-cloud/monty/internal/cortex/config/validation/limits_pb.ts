// Code generated by internal/codegen. You may edit parts of this file.
// Field numbers and custom options will be preserved for matching field names.
// All other modifications will be lost.

// @generated by protoc-gen-es v1.10.1 with parameter "target=ts,import_extension=none,ts_nocheck=false"
// @generated from file github.com/aity-cloud/monty/internal/cortex/config/validation/limits.proto (package validation, syntax proto3)
/* eslint-disable */

import type { BinaryReadOptions, FieldList, JsonReadOptions, JsonValue, PartialMessage, PlainMessage } from "@bufbuild/protobuf";
import { Duration, Message, proto3 } from "@bufbuild/protobuf";

/**
 * @generated from message validation.Limits
 */
export class Limits extends Message<Limits> {
  /**
   * Per-user ingestion rate limit in samples per second.
   *
   * @generated from field: optional double ingestion_rate = 1;
   */
  ingestionRate?: number;

  /**
   * Whether the ingestion rate limit should be applied individually to each distributor instance (local), or evenly shared across the cluster (global).
   *
   * @generated from field: optional string ingestion_rate_strategy = 2;
   */
  ingestionRateStrategy?: string;

  /**
   * Per-user allowed ingestion burst size (in number of samples).
   *
   * @generated from field: optional int32 ingestion_burst_size = 3;
   */
  ingestionBurstSize?: number;

  /**
   * Flag to enable, for all users, handling of samples with external labels identifying replicas in an HA Prometheus setup.
   *
   * @generated from field: optional bool accept_ha_samples = 4;
   */
  acceptHaSamples?: boolean;

  /**
   * Prometheus label to look for in samples to identify a Prometheus HA cluster.
   *
   * @generated from field: optional string ha_cluster_label = 5;
   */
  haClusterLabel?: string;

  /**
   * Prometheus label to look for in samples to identify a Prometheus HA replica.
   *
   * @generated from field: optional string ha_replica_label = 6;
   */
  haReplicaLabel?: string;

  /**
   * Maximum number of clusters that HA tracker will keep track of for single user. 0 to disable the limit.
   *
   * @generated from field: optional int32 ha_max_clusters = 7;
   */
  haMaxClusters?: number;

  /**
   * This flag can be used to specify label names that to drop during sample ingestion within the distributor and can be repeated in order to drop multiple labels.
   *
   * @generated from field: repeated string drop_labels = 8;
   */
  dropLabels: string[] = [];

  /**
   * Maximum length accepted for label names
   *
   * @generated from field: optional int32 max_label_name_length = 9;
   */
  maxLabelNameLength?: number;

  /**
   * Maximum length accepted for label value. This setting also applies to the metric name
   *
   * @generated from field: optional int32 max_label_value_length = 10;
   */
  maxLabelValueLength?: number;

  /**
   * Maximum number of label names per series.
   *
   * @generated from field: optional int32 max_label_names_per_series = 11;
   */
  maxLabelNamesPerSeries?: number;

  /**
   * Maximum combined size in bytes of all labels and label values accepted for a series. 0 to disable the limit.
   *
   * @generated from field: optional int32 max_labels_size_bytes = 12;
   */
  maxLabelsSizeBytes?: number;

  /**
   * Maximum length accepted for metric metadata. Metadata refers to Metric Name, HELP and UNIT.
   *
   * @generated from field: optional int32 max_metadata_length = 13;
   */
  maxMetadataLength?: number;

  /**
   * Reject old samples.
   *
   * @generated from field: optional bool reject_old_samples = 14;
   */
  rejectOldSamples?: boolean;

  /**
   * Maximum accepted sample age before rejecting.
   *
   * @generated from field: google.protobuf.Duration reject_old_samples_max_age = 15;
   */
  rejectOldSamplesMaxAge?: Duration;

  /**
   * Duration which table will be created/deleted before/after it's needed; we won't accept sample from before this time.
   *
   * @generated from field: google.protobuf.Duration creation_grace_period = 16;
   */
  creationGracePeriod?: Duration;

  /**
   * Enforce every metadata has a metric name.
   *
   * @generated from field: optional bool enforce_metadata_metric_name = 17;
   */
  enforceMetadataMetricName?: boolean;

  /**
   * Enforce every sample has a metric name.
   *
   * @generated from field: optional bool enforce_metric_name = 18;
   */
  enforceMetricName?: boolean;

  /**
   * The default tenant's shard size when the shuffle-sharding strategy is used. Must be set both on ingesters and distributors. When this setting is specified in the per-tenant overrides, a value of 0 disables shuffle sharding for the tenant.
   *
   * @generated from field: optional int32 ingestion_tenant_shard_size = 19;
   */
  ingestionTenantShardSize?: number;

  /**
   * List of metric relabel configurations. Note that in most situations, it is more effective to use metrics relabeling directly in the Prometheus server, e.g. remote_write.write_relabel_configs.
   *
   * @generated from field: repeated validation.RelabelConfig metric_relabel_configs = 20;
   */
  metricRelabelConfigs: RelabelConfig[] = [];

  /**
   * Enables support for exemplars in TSDB and sets the maximum number that will be stored. less than zero means disabled. If the value is set to zero, cortex will fallback to blocks-storage.tsdb.max-exemplars value.
   *
   * @generated from field: optional int32 max_exemplars = 21;
   */
  maxExemplars?: number;

  /**
   * Limit on total number of positive and negative buckets allowed in a single native histogram. The resolution of a histogram with more buckets will be reduced until the number of buckets is within the limit. If the limit cannot be reached, the sample will be discarded. 0 means no limit. Enforced at Distributor.
   *
   * @generated from field: optional int32 max_native_histogram_buckets = 22;
   */
  maxNativeHistogramBuckets?: number;

  /**
   * The maximum number of active series per user, per ingester. 0 to disable.
   *
   * @generated from field: optional int32 max_series_per_user = 23;
   */
  maxSeriesPerUser?: number;

  /**
   * The maximum number of active series per metric name, per ingester. 0 to disable.
   *
   * @generated from field: optional int32 max_series_per_metric = 24;
   */
  maxSeriesPerMetric?: number;

  /**
   * The maximum number of active series per user, across the cluster before replication. 0 to disable. Supported only if -distributor.shard-by-all-labels is true.
   *
   * @generated from field: optional int32 max_global_series_per_user = 25;
   */
  maxGlobalSeriesPerUser?: number;

  /**
   * The maximum number of active series per metric name, across the cluster before replication. 0 to disable.
   *
   * @generated from field: optional int32 max_global_series_per_metric = 26;
   */
  maxGlobalSeriesPerMetric?: number;

  /**
   * The maximum number of active metrics with metadata per user, per ingester. 0 to disable.
   *
   * @generated from field: optional int32 max_metadata_per_user = 27;
   */
  maxMetadataPerUser?: number;

  /**
   * The maximum number of metadata per metric, per ingester. 0 to disable.
   *
   * @generated from field: optional int32 max_metadata_per_metric = 28;
   */
  maxMetadataPerMetric?: number;

  /**
   * The maximum number of active metrics with metadata per user, across the cluster. 0 to disable. Supported only if -distributor.shard-by-all-labels is true.
   *
   * @generated from field: optional int32 max_global_metadata_per_user = 29;
   */
  maxGlobalMetadataPerUser?: number;

  /**
   * The maximum number of metadata per metric, across the cluster. 0 to disable.
   *
   * @generated from field: optional int32 max_global_metadata_per_metric = 30;
   */
  maxGlobalMetadataPerMetric?: number;

  /**
   * [Experimental] Configures the allowed time window for ingestion of out-of-order samples. Disabled (0s) by default.
   *
   * @generated from field: google.protobuf.Duration out_of_order_time_window = 31;
   */
  outOfOrderTimeWindow?: Duration;

  /**
   * Maximum number of chunks that can be fetched in a single query from ingesters and long-term storage. This limit is enforced in the querier, ruler and store-gateway. 0 to disable.
   *
   * @generated from field: optional int32 max_fetched_chunks_per_query = 32;
   */
  maxFetchedChunksPerQuery?: number;

  /**
   * The maximum number of unique series for which a query can fetch samples from each ingesters and blocks storage. This limit is enforced in the querier, ruler and store-gateway. 0 to disable
   *
   * @generated from field: optional int32 max_fetched_series_per_query = 33;
   */
  maxFetchedSeriesPerQuery?: number;

  /**
   * Deprecated (use max-fetched-data-bytes-per-query instead): The maximum size of all chunks in bytes that a query can fetch from each ingester and storage. This limit is enforced in the querier, ruler and store-gateway. 0 to disable.
   *
   * @generated from field: optional int32 max_fetched_chunk_bytes_per_query = 34;
   */
  maxFetchedChunkBytesPerQuery?: number;

  /**
   * The maximum combined size of all data that a query can fetch from each ingester and storage. This limit is enforced in the querier and ruler for `query`, `query_range` and `series` APIs. 0 to disable.
   *
   * @generated from field: optional int32 max_fetched_data_bytes_per_query = 35;
   */
  maxFetchedDataBytesPerQuery?: number;

  /**
   * Limit how long back data (series and metadata) can be queried, up until <lookback> duration ago. This limit is enforced in the query-frontend, querier and ruler. If the requested time range is outside the allowed range, the request will not fail but will be manipulated to only query data within the allowed time range. 0 to disable.
   *
   * @generated from field: google.protobuf.Duration max_query_lookback = 36;
   */
  maxQueryLookback?: Duration;

  /**
   * Limit the query time range (end - start time of range query parameter and max - min of data fetched time range). This limit is enforced in the query-frontend and ruler (on the received query). 0 to disable.
   *
   * @generated from field: google.protobuf.Duration max_query_length = 37;
   */
  maxQueryLength?: Duration;

  /**
   * Maximum number of split queries will be scheduled in parallel by the frontend.
   *
   * @generated from field: optional int32 max_query_parallelism = 38;
   */
  maxQueryParallelism?: number;

  /**
   * Most recent allowed cacheable result per-tenant, to prevent caching very recent results that might still be in flux.
   *
   * @generated from field: google.protobuf.Duration max_cache_freshness = 39;
   */
  maxCacheFreshness?: Duration;

  /**
   * Maximum number of queriers that can handle requests for a single tenant. If set to 0 or value higher than number of available queriers, *all* queriers will handle requests for the tenant. If the value is < 1, it will be treated as a percentage and the gets a percentage of the total queriers. Each frontend (or query-scheduler, if used) will select the same set of queriers for the same tenant (given that all queriers are connected to all frontends / query-schedulers). This option only works with queriers connecting to the query-frontend / query-scheduler, not when using downstream URL.
   *
   * @generated from field: optional double max_queriers_per_tenant = 40;
   */
  maxQueriersPerTenant?: number;

  /**
   * Maximum number of outstanding requests per tenant per request queue (either query frontend or query scheduler); requests beyond this error with HTTP 429.
   *
   * @generated from field: optional int32 max_outstanding_requests_per_tenant = 41;
   */
  maxOutstandingRequestsPerTenant?: number;

  /**
   * Deprecated(use ruler.query-offset instead) and will be removed in v1.19.0: Duration to delay the evaluation of rules to ensure the underlying metrics have been pushed to Cortex.
   *
   * @generated from field: google.protobuf.Duration ruler_evaluation_delay_duration = 42;
   */
  rulerEvaluationDelayDuration?: Duration;

  /**
   * The default tenant's shard size when the shuffle-sharding strategy is used by ruler. When this setting is specified in the per-tenant overrides, a value of 0 disables shuffle sharding for the tenant.
   *
   * @generated from field: optional int32 ruler_tenant_shard_size = 43;
   */
  rulerTenantShardSize?: number;

  /**
   * Maximum number of rules per rule group per-tenant. 0 to disable.
   *
   * @generated from field: optional int32 ruler_max_rules_per_rule_group = 44;
   */
  rulerMaxRulesPerRuleGroup?: number;

  /**
   * Maximum number of rule groups per-tenant. 0 to disable.
   *
   * @generated from field: optional int32 ruler_max_rule_groups_per_tenant = 45;
   */
  rulerMaxRuleGroupsPerTenant?: number;

  /**
   * The default tenant's shard size when the shuffle-sharding strategy is used. Must be set when the store-gateway sharding is enabled with the shuffle-sharding strategy. When this setting is specified in the per-tenant overrides, a value of 0 disables shuffle sharding for the tenant. If the value is < 1 the shard size will be a percentage of the total store-gateways.
   *
   * @generated from field: optional double store_gateway_tenant_shard_size = 46;
   */
  storeGatewayTenantShardSize?: number;

  /**
   * The maximum number of data bytes to download per gRPC request in Store Gateway, including Series/LabelNames/LabelValues requests. 0 to disable.
   *
   * @generated from field: optional int32 max_downloaded_bytes_per_request = 47;
   */
  maxDownloadedBytesPerRequest?: number;

  /**
   * Delete blocks containing samples older than the specified retention period. 0 to disable.
   *
   * @generated from field: google.protobuf.Duration compactor_blocks_retention_period = 48;
   */
  compactorBlocksRetentionPeriod?: Duration;

  /**
   * The default tenant's shard size when the shuffle-sharding strategy is used by the compactor. When this setting is specified in the per-tenant overrides, a value of 0 disables shuffle sharding for the tenant.
   *
   * @generated from field: optional int32 compactor_tenant_shard_size = 49;
   */
  compactorTenantShardSize?: number;

  /**
   * S3 server-side encryption type. Required to enable server-side encryption overrides for a specific tenant. If not set, the default S3 client settings are used.
   *
   * @generated from field: optional string s3_sse_type = 50;
   */
  s3SseType?: string;

  /**
   * S3 server-side encryption KMS Key ID. Ignored if the SSE type override is not set.
   *
   * @generated from field: optional string s3_sse_kms_key_id = 51;
   */
  s3SseKmsKeyId?: string;

  /**
   * S3 server-side encryption KMS encryption context. If unset and the key ID override is set, the encryption context will not be provided to S3. Ignored if the SSE type override is not set.
   *
   * @generated from field: optional string s3_sse_kms_encryption_context = 52;
   */
  s3SseKmsEncryptionContext?: string;

  /**
   * Comma-separated list of network CIDRs to block in Alertmanager receiver integrations.
   *
   * @generated from field: repeated string alertmanager_receivers_firewall_block_cidr_networks = 53;
   */
  alertmanagerReceiversFirewallBlockCidrNetworks: string[] = [];

  /**
   * True to block private and local addresses in Alertmanager receiver integrations. It blocks private addresses defined by  RFC 1918 (IPv4 addresses) and RFC 4193 (IPv6 addresses), as well as loopback, local unicast and local multicast addresses.
   *
   * @generated from field: optional bool alertmanager_receivers_firewall_block_private_addresses = 54;
   */
  alertmanagerReceiversFirewallBlockPrivateAddresses?: boolean;

  /**
   * Per-user rate limit for sending notifications from Alertmanager in notifications/sec. 0 = rate limit disabled. Negative value = no notifications are allowed.
   *
   * @generated from field: optional double alertmanager_notification_rate_limit = 55;
   */
  alertmanagerNotificationRateLimit?: number;

  /**
   * Per-integration notification rate limits. Value is a map, where each key is integration name and value is a rate-limit (float). On command line, this map is given in JSON format. Rate limit has the same meaning as -alertmanager.notification-rate-limit, but only applies for specific integration. Allowed integration names: webhook, email, pagerduty, opsgenie, wechat, slack, victorops, pushover, sns, telegram, discord, webex, msteams.
   *
   * @generated from field: map<string, double> alertmanager_notification_rate_limit_per_integration = 56;
   */
  alertmanagerNotificationRateLimitPerIntegration: { [key: string]: number } = {};

  /**
   * Maximum size of configuration file for Alertmanager that tenant can upload via Alertmanager API. 0 = no limit.
   *
   * @generated from field: optional int32 alertmanager_max_config_size_bytes = 57;
   */
  alertmanagerMaxConfigSizeBytes?: number;

  /**
   * Maximum number of templates in tenant's Alertmanager configuration uploaded via Alertmanager API. 0 = no limit.
   *
   * @generated from field: optional int32 alertmanager_max_templates_count = 58;
   */
  alertmanagerMaxTemplatesCount?: number;

  /**
   * Maximum size of single template in tenant's Alertmanager configuration uploaded via Alertmanager API. 0 = no limit.
   *
   * @generated from field: optional int32 alertmanager_max_template_size_bytes = 59;
   */
  alertmanagerMaxTemplateSizeBytes?: number;

  /**
   * Maximum number of aggregation groups in Alertmanager's dispatcher that a tenant can have. Each active aggregation group uses single goroutine. When the limit is reached, dispatcher will not dispatch alerts that belong to additional aggregation groups, but existing groups will keep working properly. 0 = no limit.
   *
   * @generated from field: optional int32 alertmanager_max_dispatcher_aggregation_groups = 60;
   */
  alertmanagerMaxDispatcherAggregationGroups?: number;

  /**
   * Maximum number of alerts that a single user can have. Inserting more alerts will fail with a log message and metric increment. 0 = no limit.
   *
   * @generated from field: optional int32 alertmanager_max_alerts_count = 61;
   */
  alertmanagerMaxAlertsCount?: number;

  /**
   * Maximum total size of alerts that a single user can have, alert size is the sum of the bytes of its labels, annotations and generatorURL. Inserting more alerts will fail with a log message and metric increment. 0 = no limit.
   *
   * @generated from field: optional int32 alertmanager_max_alerts_size_bytes = 62;
   */
  alertmanagerMaxAlertsSizeBytes?: number;

  /**
   * list of rule groups to disable
   *
   * @generated from field: repeated validation.DisabledRuleGroup disabled_rule_groups = 63;
   */
  disabledRuleGroups: DisabledRuleGroup[] = [];

  /**
   * [Experimental] Flag to enable handling of samples with mixed external labels identifying replicas in an HA Prometheus setup. Supported only if -distributor.ha-tracker.enable-for-all-users is true.
   *
   * @generated from field: optional bool accept_mixed_ha_samples = 73;
   */
  acceptMixedHaSamples?: boolean;

  /**
   * Comma separated list of resource attributes that should be converted to labels.
   *
   * @generated from field: repeated string promote_resource_attributes = 74;
   */
  promoteResourceAttributes: string[] = [];

  /**
   * [Experimental] Enable limits per LabelSet. Supported limits per labelSet: [max_series]
   *
   * @generated from field: repeated validation.LimitsPerLabelSet limits_per_label_set = 75;
   */
  limitsPerLabelSet: LimitsPerLabelSet[] = [];

  /**
   * Configuration for query priority.
   *
   * @generated from field: validation.QueryPriority query_priority = 76;
   */
  queryPriority?: QueryPriority;

  /**
   * Configuration for query rejection.
   *
   * @generated from field: validation.QueryRejection query_rejection = 77;
   */
  queryRejection?: QueryRejection;

  /**
   * Duration to offset all rule evaluation queries per-tenant.
   *
   * @generated from field: google.protobuf.Duration ruler_query_offset = 78;
   */
  rulerQueryOffset?: Duration;

  /**
   * external labels for alerting rules
   *
   * @generated from field: repeated validation.LabelsLabel ruler_external_labels = 79;
   */
  rulerExternalLabels: LabelsLabel[] = [];

  /**
   * Index size limit in bytes for each compaction partition. 0 means no limit
   *
   * @generated from field: optional int64 compactor_partition_index_size_bytes = 80;
   */
  compactorPartitionIndexSizeBytes?: bigint;

  /**
   * Time series count limit for each compaction partition. 0 means no limit
   *
   * @generated from field: optional int64 compactor_partition_series_count = 81;
   */
  compactorPartitionSeriesCount?: bigint;

  constructor(data?: PartialMessage<Limits>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "validation.Limits";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "ingestion_rate", kind: "scalar", T: 1 /* ScalarType.DOUBLE */, opt: true },
    { no: 2, name: "ingestion_rate_strategy", kind: "scalar", T: 9 /* ScalarType.STRING */, opt: true },
    { no: 3, name: "ingestion_burst_size", kind: "scalar", T: 5 /* ScalarType.INT32 */, opt: true },
    { no: 4, name: "accept_ha_samples", kind: "scalar", T: 8 /* ScalarType.BOOL */, opt: true },
    { no: 5, name: "ha_cluster_label", kind: "scalar", T: 9 /* ScalarType.STRING */, opt: true },
    { no: 6, name: "ha_replica_label", kind: "scalar", T: 9 /* ScalarType.STRING */, opt: true },
    { no: 7, name: "ha_max_clusters", kind: "scalar", T: 5 /* ScalarType.INT32 */, opt: true },
    { no: 8, name: "drop_labels", kind: "scalar", T: 9 /* ScalarType.STRING */, repeated: true },
    { no: 9, name: "max_label_name_length", kind: "scalar", T: 5 /* ScalarType.INT32 */, opt: true },
    { no: 10, name: "max_label_value_length", kind: "scalar", T: 5 /* ScalarType.INT32 */, opt: true },
    { no: 11, name: "max_label_names_per_series", kind: "scalar", T: 5 /* ScalarType.INT32 */, opt: true },
    { no: 12, name: "max_labels_size_bytes", kind: "scalar", T: 5 /* ScalarType.INT32 */, opt: true },
    { no: 13, name: "max_metadata_length", kind: "scalar", T: 5 /* ScalarType.INT32 */, opt: true },
    { no: 14, name: "reject_old_samples", kind: "scalar", T: 8 /* ScalarType.BOOL */, opt: true },
    { no: 15, name: "reject_old_samples_max_age", kind: "message", T: Duration },
    { no: 16, name: "creation_grace_period", kind: "message", T: Duration },
    { no: 17, name: "enforce_metadata_metric_name", kind: "scalar", T: 8 /* ScalarType.BOOL */, opt: true },
    { no: 18, name: "enforce_metric_name", kind: "scalar", T: 8 /* ScalarType.BOOL */, opt: true },
    { no: 19, name: "ingestion_tenant_shard_size", kind: "scalar", T: 5 /* ScalarType.INT32 */, opt: true },
    { no: 20, name: "metric_relabel_configs", kind: "message", T: RelabelConfig, repeated: true },
    { no: 21, name: "max_exemplars", kind: "scalar", T: 5 /* ScalarType.INT32 */, opt: true },
    { no: 22, name: "max_native_histogram_buckets", kind: "scalar", T: 5 /* ScalarType.INT32 */, opt: true },
    { no: 23, name: "max_series_per_user", kind: "scalar", T: 5 /* ScalarType.INT32 */, opt: true },
    { no: 24, name: "max_series_per_metric", kind: "scalar", T: 5 /* ScalarType.INT32 */, opt: true },
    { no: 25, name: "max_global_series_per_user", kind: "scalar", T: 5 /* ScalarType.INT32 */, opt: true },
    { no: 26, name: "max_global_series_per_metric", kind: "scalar", T: 5 /* ScalarType.INT32 */, opt: true },
    { no: 27, name: "max_metadata_per_user", kind: "scalar", T: 5 /* ScalarType.INT32 */, opt: true },
    { no: 28, name: "max_metadata_per_metric", kind: "scalar", T: 5 /* ScalarType.INT32 */, opt: true },
    { no: 29, name: "max_global_metadata_per_user", kind: "scalar", T: 5 /* ScalarType.INT32 */, opt: true },
    { no: 30, name: "max_global_metadata_per_metric", kind: "scalar", T: 5 /* ScalarType.INT32 */, opt: true },
    { no: 31, name: "out_of_order_time_window", kind: "message", T: Duration },
    { no: 32, name: "max_fetched_chunks_per_query", kind: "scalar", T: 5 /* ScalarType.INT32 */, opt: true },
    { no: 33, name: "max_fetched_series_per_query", kind: "scalar", T: 5 /* ScalarType.INT32 */, opt: true },
    { no: 34, name: "max_fetched_chunk_bytes_per_query", kind: "scalar", T: 5 /* ScalarType.INT32 */, opt: true },
    { no: 35, name: "max_fetched_data_bytes_per_query", kind: "scalar", T: 5 /* ScalarType.INT32 */, opt: true },
    { no: 36, name: "max_query_lookback", kind: "message", T: Duration },
    { no: 37, name: "max_query_length", kind: "message", T: Duration },
    { no: 38, name: "max_query_parallelism", kind: "scalar", T: 5 /* ScalarType.INT32 */, opt: true },
    { no: 39, name: "max_cache_freshness", kind: "message", T: Duration },
    { no: 40, name: "max_queriers_per_tenant", kind: "scalar", T: 1 /* ScalarType.DOUBLE */, opt: true },
    { no: 41, name: "max_outstanding_requests_per_tenant", kind: "scalar", T: 5 /* ScalarType.INT32 */, opt: true },
    { no: 42, name: "ruler_evaluation_delay_duration", kind: "message", T: Duration },
    { no: 43, name: "ruler_tenant_shard_size", kind: "scalar", T: 5 /* ScalarType.INT32 */, opt: true },
    { no: 44, name: "ruler_max_rules_per_rule_group", kind: "scalar", T: 5 /* ScalarType.INT32 */, opt: true },
    { no: 45, name: "ruler_max_rule_groups_per_tenant", kind: "scalar", T: 5 /* ScalarType.INT32 */, opt: true },
    { no: 46, name: "store_gateway_tenant_shard_size", kind: "scalar", T: 1 /* ScalarType.DOUBLE */, opt: true },
    { no: 47, name: "max_downloaded_bytes_per_request", kind: "scalar", T: 5 /* ScalarType.INT32 */, opt: true },
    { no: 48, name: "compactor_blocks_retention_period", kind: "message", T: Duration },
    { no: 49, name: "compactor_tenant_shard_size", kind: "scalar", T: 5 /* ScalarType.INT32 */, opt: true },
    { no: 50, name: "s3_sse_type", kind: "scalar", T: 9 /* ScalarType.STRING */, opt: true },
    { no: 51, name: "s3_sse_kms_key_id", kind: "scalar", T: 9 /* ScalarType.STRING */, opt: true },
    { no: 52, name: "s3_sse_kms_encryption_context", kind: "scalar", T: 9 /* ScalarType.STRING */, opt: true },
    { no: 53, name: "alertmanager_receivers_firewall_block_cidr_networks", kind: "scalar", T: 9 /* ScalarType.STRING */, repeated: true },
    { no: 54, name: "alertmanager_receivers_firewall_block_private_addresses", kind: "scalar", T: 8 /* ScalarType.BOOL */, opt: true },
    { no: 55, name: "alertmanager_notification_rate_limit", kind: "scalar", T: 1 /* ScalarType.DOUBLE */, opt: true },
    { no: 56, name: "alertmanager_notification_rate_limit_per_integration", kind: "map", K: 9 /* ScalarType.STRING */, V: {kind: "scalar", T: 1 /* ScalarType.DOUBLE */} },
    { no: 57, name: "alertmanager_max_config_size_bytes", kind: "scalar", T: 5 /* ScalarType.INT32 */, opt: true },
    { no: 58, name: "alertmanager_max_templates_count", kind: "scalar", T: 5 /* ScalarType.INT32 */, opt: true },
    { no: 59, name: "alertmanager_max_template_size_bytes", kind: "scalar", T: 5 /* ScalarType.INT32 */, opt: true },
    { no: 60, name: "alertmanager_max_dispatcher_aggregation_groups", kind: "scalar", T: 5 /* ScalarType.INT32 */, opt: true },
    { no: 61, name: "alertmanager_max_alerts_count", kind: "scalar", T: 5 /* ScalarType.INT32 */, opt: true },
    { no: 62, name: "alertmanager_max_alerts_size_bytes", kind: "scalar", T: 5 /* ScalarType.INT32 */, opt: true },
    { no: 63, name: "disabled_rule_groups", kind: "message", T: DisabledRuleGroup, repeated: true },
    { no: 73, name: "accept_mixed_ha_samples", kind: "scalar", T: 8 /* ScalarType.BOOL */, opt: true },
    { no: 74, name: "promote_resource_attributes", kind: "scalar", T: 9 /* ScalarType.STRING */, repeated: true },
    { no: 75, name: "limits_per_label_set", kind: "message", T: LimitsPerLabelSet, repeated: true },
    { no: 76, name: "query_priority", kind: "message", T: QueryPriority },
    { no: 77, name: "query_rejection", kind: "message", T: QueryRejection },
    { no: 78, name: "ruler_query_offset", kind: "message", T: Duration },
    { no: 79, name: "ruler_external_labels", kind: "message", T: LabelsLabel, repeated: true },
    { no: 80, name: "compactor_partition_index_size_bytes", kind: "scalar", T: 3 /* ScalarType.INT64 */, opt: true },
    { no: 81, name: "compactor_partition_series_count", kind: "scalar", T: 3 /* ScalarType.INT64 */, opt: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): Limits {
    return new Limits().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): Limits {
    return new Limits().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): Limits {
    return new Limits().fromJsonString(jsonString, options);
  }

  static equals(a: Limits | PlainMessage<Limits> | undefined, b: Limits | PlainMessage<Limits> | undefined): boolean {
    return proto3.util.equals(Limits, a, b);
  }
}

/**
 * @generated from message validation.DisabledRuleGroup
 */
export class DisabledRuleGroup extends Message<DisabledRuleGroup> {
  /**
   * namespace in which the rule group belongs
   *
   * @generated from field: optional string namespace = 1;
   */
  namespace?: string;

  /**
   * name of the rule group
   *
   * @generated from field: optional string name = 2;
   */
  name?: string;

  constructor(data?: PartialMessage<DisabledRuleGroup>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "validation.DisabledRuleGroup";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "namespace", kind: "scalar", T: 9 /* ScalarType.STRING */, opt: true },
    { no: 2, name: "name", kind: "scalar", T: 9 /* ScalarType.STRING */, opt: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): DisabledRuleGroup {
    return new DisabledRuleGroup().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): DisabledRuleGroup {
    return new DisabledRuleGroup().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): DisabledRuleGroup {
    return new DisabledRuleGroup().fromJsonString(jsonString, options);
  }

  static equals(a: DisabledRuleGroup | PlainMessage<DisabledRuleGroup> | undefined, b: DisabledRuleGroup | PlainMessage<DisabledRuleGroup> | undefined): boolean {
    return proto3.util.equals(DisabledRuleGroup, a, b);
  }
}

/**
 * @generated from message validation.LimitsPerLabelSet
 */
export class LimitsPerLabelSet extends Message<LimitsPerLabelSet> {
  /**
   * @generated from field: validation.LimitsPerLabelSetEntry limits = 1;
   */
  limits?: LimitsPerLabelSetEntry;

  /**
   * LabelSet which the limit should be applied. If no labels are provided, it becomes the default partition which matches any series that doesn't match any other explicitly defined label sets.'
   *
   * @generated from field: repeated validation.LabelsLabel label_set = 2;
   */
  labelSet: LabelsLabel[] = [];

  constructor(data?: PartialMessage<LimitsPerLabelSet>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "validation.LimitsPerLabelSet";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "limits", kind: "message", T: LimitsPerLabelSetEntry },
    { no: 2, name: "label_set", kind: "message", T: LabelsLabel, repeated: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): LimitsPerLabelSet {
    return new LimitsPerLabelSet().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): LimitsPerLabelSet {
    return new LimitsPerLabelSet().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): LimitsPerLabelSet {
    return new LimitsPerLabelSet().fromJsonString(jsonString, options);
  }

  static equals(a: LimitsPerLabelSet | PlainMessage<LimitsPerLabelSet> | undefined, b: LimitsPerLabelSet | PlainMessage<LimitsPerLabelSet> | undefined): boolean {
    return proto3.util.equals(LimitsPerLabelSet, a, b);
  }
}

/**
 * @generated from message validation.LimitsPerLabelSetEntry
 */
export class LimitsPerLabelSetEntry extends Message<LimitsPerLabelSetEntry> {
  /**
   * The maximum number of active series per LabelSet, across the cluster before replication. Setting the value 0 will enable the monitoring (metrics) but would not enforce any limits.
   *
   * @generated from field: optional int32 max_series = 1;
   */
  maxSeries?: number;

  constructor(data?: PartialMessage<LimitsPerLabelSetEntry>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "validation.LimitsPerLabelSetEntry";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "max_series", kind: "scalar", T: 5 /* ScalarType.INT32 */, opt: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): LimitsPerLabelSetEntry {
    return new LimitsPerLabelSetEntry().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): LimitsPerLabelSetEntry {
    return new LimitsPerLabelSetEntry().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): LimitsPerLabelSetEntry {
    return new LimitsPerLabelSetEntry().fromJsonString(jsonString, options);
  }

  static equals(a: LimitsPerLabelSetEntry | PlainMessage<LimitsPerLabelSetEntry> | undefined, b: LimitsPerLabelSetEntry | PlainMessage<LimitsPerLabelSetEntry> | undefined): boolean {
    return proto3.util.equals(LimitsPerLabelSetEntry, a, b);
  }
}

/**
 * @generated from message validation.PriorityDef
 */
export class PriorityDef extends Message<PriorityDef> {
  /**
   * Priority level. Must be a unique value.
   *
   * @generated from field: optional int64 priority = 1;
   */
  priority?: bigint;

  /**
   * Number of reserved queriers to handle priorities higher or equal to the priority level. Value between 0 and 1 will be used as a percentage.
   *
   * @generated from field: optional double reserved_queriers = 2;
   */
  reservedQueriers?: number;

  /**
   * List of query_attributes to match and assign priority to queries. A query is assigned to this priority if it matches any query_attribute in this list. Each query_attribute has several properties (e.g., regex, time_window, user_agent), and all specified properties must match for a query_attribute to be considered a match. Only the specified properties are checked, and an AND operator is applied to them.
   *
   * @generated from field: repeated validation.QueryAttribute query_attributes = 3;
   */
  queryAttributes: QueryAttribute[] = [];

  constructor(data?: PartialMessage<PriorityDef>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "validation.PriorityDef";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "priority", kind: "scalar", T: 3 /* ScalarType.INT64 */, opt: true },
    { no: 2, name: "reserved_queriers", kind: "scalar", T: 1 /* ScalarType.DOUBLE */, opt: true },
    { no: 3, name: "query_attributes", kind: "message", T: QueryAttribute, repeated: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): PriorityDef {
    return new PriorityDef().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): PriorityDef {
    return new PriorityDef().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): PriorityDef {
    return new PriorityDef().fromJsonString(jsonString, options);
  }

  static equals(a: PriorityDef | PlainMessage<PriorityDef> | undefined, b: PriorityDef | PlainMessage<PriorityDef> | undefined): boolean {
    return proto3.util.equals(PriorityDef, a, b);
  }
}

/**
 * @generated from message validation.QueryAttribute
 */
export class QueryAttribute extends Message<QueryAttribute> {
  /**
   * API type for the query. Should be one of the query, query_range, series, labels, label_values. If not set, it won't be checked.
   *
   * @generated from field: optional string api_type = 1;
   */
  apiType?: string;

  /**
   * Regex that the query string (or at least one of the matchers in metadata query) should match. If not set, it won't be checked.
   *
   * @generated from field: optional string regex = 2;
   */
  regex?: string;

  /**
   * Overall data select time window (including range selectors, modifiers and lookback delta) that the query should be within. If not set, it won't be checked.
   *
   * @generated from field: validation.TimeWindow time_window = 3;
   */
  timeWindow?: TimeWindow;

  /**
   * Query time range should be within this limit to match. Depending on where it was used, in most of the use-cases, either min or max value will be used. If not set, it won't be checked.
   *
   * @generated from field: validation.TimeRangeLimit time_range_limit = 4;
   */
  timeRangeLimit?: TimeRangeLimit;

  /**
   * If query step provided should be within this limit to match. If not set, it won't be checked. This property only applied to range queries and ignored for other types of queries.
   *
   * @generated from field: validation.QueryStepLimit query_step_limit = 5;
   */
  queryStepLimit?: QueryStepLimit;

  /**
   * Regex that User-Agent header of the request should match. If not set, it won't be checked.
   *
   * @generated from field: optional string user_agent_regex = 6;
   */
  userAgentRegex?: string;

  /**
   * Grafana includes X-Dashboard-Uid header in query requests. If this field is provided then X-Dashboard-Uid header of request should match this value. If not set, it won't be checked. This property won't be applied to metadata queries.
   *
   * @generated from field: optional string dashboard_uid = 7;
   */
  dashboardUid?: string;

  /**
   * Grafana includes X-Panel-Id header in query requests. If this field is provided then X-Panel-Id header of request should match this value. If not set, it won't be checked. This property won't be applied to metadata queries.
   *
   * @generated from field: optional string panel_id = 8;
   */
  panelId?: string;

  /**
   * @generated from field: validation.RegexpRegexp CompiledRegex = 9;
   */
  CompiledRegex?: RegexpRegexp;

  /**
   * @generated from field: validation.RegexpRegexp CompiledUserAgentRegex = 10;
   */
  CompiledUserAgentRegex?: RegexpRegexp;

  constructor(data?: PartialMessage<QueryAttribute>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "validation.QueryAttribute";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "api_type", kind: "scalar", T: 9 /* ScalarType.STRING */, opt: true },
    { no: 2, name: "regex", kind: "scalar", T: 9 /* ScalarType.STRING */, opt: true },
    { no: 3, name: "time_window", kind: "message", T: TimeWindow },
    { no: 4, name: "time_range_limit", kind: "message", T: TimeRangeLimit },
    { no: 5, name: "query_step_limit", kind: "message", T: QueryStepLimit },
    { no: 6, name: "user_agent_regex", kind: "scalar", T: 9 /* ScalarType.STRING */, opt: true },
    { no: 7, name: "dashboard_uid", kind: "scalar", T: 9 /* ScalarType.STRING */, opt: true },
    { no: 8, name: "panel_id", kind: "scalar", T: 9 /* ScalarType.STRING */, opt: true },
    { no: 9, name: "CompiledRegex", kind: "message", T: RegexpRegexp },
    { no: 10, name: "CompiledUserAgentRegex", kind: "message", T: RegexpRegexp },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): QueryAttribute {
    return new QueryAttribute().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): QueryAttribute {
    return new QueryAttribute().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): QueryAttribute {
    return new QueryAttribute().fromJsonString(jsonString, options);
  }

  static equals(a: QueryAttribute | PlainMessage<QueryAttribute> | undefined, b: QueryAttribute | PlainMessage<QueryAttribute> | undefined): boolean {
    return proto3.util.equals(QueryAttribute, a, b);
  }
}

/**
 * @generated from message validation.QueryPriority
 */
export class QueryPriority extends Message<QueryPriority> {
  /**
   * @generated from field: optional bool enabled = 1;
   */
  enabled?: boolean;

  /**
   * @generated from field: optional int64 default_priority = 2;
   */
  defaultPriority?: bigint;

  /**
   * List of priority definitions.
   *
   * @generated from field: repeated validation.PriorityDef priorities = 3;
   */
  priorities: PriorityDef[] = [];

  constructor(data?: PartialMessage<QueryPriority>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "validation.QueryPriority";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "enabled", kind: "scalar", T: 8 /* ScalarType.BOOL */, opt: true },
    { no: 2, name: "default_priority", kind: "scalar", T: 3 /* ScalarType.INT64 */, opt: true },
    { no: 3, name: "priorities", kind: "message", T: PriorityDef, repeated: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): QueryPriority {
    return new QueryPriority().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): QueryPriority {
    return new QueryPriority().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): QueryPriority {
    return new QueryPriority().fromJsonString(jsonString, options);
  }

  static equals(a: QueryPriority | PlainMessage<QueryPriority> | undefined, b: QueryPriority | PlainMessage<QueryPriority> | undefined): boolean {
    return proto3.util.equals(QueryPriority, a, b);
  }
}

/**
 * @generated from message validation.QueryRejection
 */
export class QueryRejection extends Message<QueryRejection> {
  /**
   * @generated from field: optional bool enabled = 1;
   */
  enabled?: boolean;

  /**
   * List of query_attributes to match and reject queries. A query is rejected if it matches any query_attribute in this list. Each query_attribute has several properties (e.g., regex, time_window, user_agent), and all specified properties must match for a query_attribute to be considered a match. Only the specified properties are checked, and an AND operator is applied to them.
   *
   * @generated from field: repeated validation.QueryAttribute query_attributes = 2;
   */
  queryAttributes: QueryAttribute[] = [];

  constructor(data?: PartialMessage<QueryRejection>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "validation.QueryRejection";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "enabled", kind: "scalar", T: 8 /* ScalarType.BOOL */, opt: true },
    { no: 2, name: "query_attributes", kind: "message", T: QueryAttribute, repeated: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): QueryRejection {
    return new QueryRejection().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): QueryRejection {
    return new QueryRejection().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): QueryRejection {
    return new QueryRejection().fromJsonString(jsonString, options);
  }

  static equals(a: QueryRejection | PlainMessage<QueryRejection> | undefined, b: QueryRejection | PlainMessage<QueryRejection> | undefined): boolean {
    return proto3.util.equals(QueryRejection, a, b);
  }
}

/**
 * @generated from message validation.QueryStepLimit
 */
export class QueryStepLimit extends Message<QueryStepLimit> {
  /**
   * Query step should be above or equal to this value to match. If set to 0, it won't be checked.
   *
   * @generated from field: google.protobuf.Duration min = 1;
   */
  min?: Duration;

  /**
   * Query step should be below or equal to this value to match. If set to 0, it won't be checked.
   *
   * @generated from field: google.protobuf.Duration max = 2;
   */
  max?: Duration;

  constructor(data?: PartialMessage<QueryStepLimit>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "validation.QueryStepLimit";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "min", kind: "message", T: Duration },
    { no: 2, name: "max", kind: "message", T: Duration },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): QueryStepLimit {
    return new QueryStepLimit().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): QueryStepLimit {
    return new QueryStepLimit().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): QueryStepLimit {
    return new QueryStepLimit().fromJsonString(jsonString, options);
  }

  static equals(a: QueryStepLimit | PlainMessage<QueryStepLimit> | undefined, b: QueryStepLimit | PlainMessage<QueryStepLimit> | undefined): boolean {
    return proto3.util.equals(QueryStepLimit, a, b);
  }
}

/**
 * @generated from message validation.TimeRangeLimit
 */
export class TimeRangeLimit extends Message<TimeRangeLimit> {
  /**
   * This will be duration (12h, 1d, 15d etc.). Query time range should be above or equal to this value to match. Ex: if this value is 20d, then queries whose range is bigger than or equal to 20d will match. If set to 0, it won't be checked.
   *
   * @generated from field: google.protobuf.Duration min = 1;
   */
  min?: Duration;

  /**
   * This will be duration (12h, 1d, 15d etc.). Query time range should be below or equal to this value to match. Ex: if this value is 24h, then queries whose range is smaller than or equal to 24h will match.If set to 0, it won't be checked.
   *
   * @generated from field: google.protobuf.Duration max = 2;
   */
  max?: Duration;

  constructor(data?: PartialMessage<TimeRangeLimit>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "validation.TimeRangeLimit";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "min", kind: "message", T: Duration },
    { no: 2, name: "max", kind: "message", T: Duration },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): TimeRangeLimit {
    return new TimeRangeLimit().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): TimeRangeLimit {
    return new TimeRangeLimit().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): TimeRangeLimit {
    return new TimeRangeLimit().fromJsonString(jsonString, options);
  }

  static equals(a: TimeRangeLimit | PlainMessage<TimeRangeLimit> | undefined, b: TimeRangeLimit | PlainMessage<TimeRangeLimit> | undefined): boolean {
    return proto3.util.equals(TimeRangeLimit, a, b);
  }
}

/**
 * @generated from message validation.TimeWindow
 */
export class TimeWindow extends Message<TimeWindow> {
  /**
   * Start of the data select time window (including range selectors, modifiers and lookback delta) that the query should be within. If set to 0, it won't be checked.
   *
   * @generated from field: google.protobuf.Duration start = 1;
   */
  start?: Duration;

  /**
   * End of the data select time window (including range selectors, modifiers and lookback delta) that the query should be within. If set to 0, it won't be checked.
   *
   * @generated from field: google.protobuf.Duration end = 2;
   */
  end?: Duration;

  constructor(data?: PartialMessage<TimeWindow>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "validation.TimeWindow";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "start", kind: "message", T: Duration },
    { no: 2, name: "end", kind: "message", T: Duration },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): TimeWindow {
    return new TimeWindow().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): TimeWindow {
    return new TimeWindow().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): TimeWindow {
    return new TimeWindow().fromJsonString(jsonString, options);
  }

  static equals(a: TimeWindow | PlainMessage<TimeWindow> | undefined, b: TimeWindow | PlainMessage<TimeWindow> | undefined): boolean {
    return proto3.util.equals(TimeWindow, a, b);
  }
}

/**
 * @generated from message validation.LabelsLabel
 */
export class LabelsLabel extends Message<LabelsLabel> {
  /**
   * @generated from field: optional string Name = 1;
   */
  Name?: string;

  /**
   * @generated from field: optional string Value = 2;
   */
  Value?: string;

  constructor(data?: PartialMessage<LabelsLabel>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "validation.LabelsLabel";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "Name", kind: "scalar", T: 9 /* ScalarType.STRING */, opt: true },
    { no: 2, name: "Value", kind: "scalar", T: 9 /* ScalarType.STRING */, opt: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): LabelsLabel {
    return new LabelsLabel().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): LabelsLabel {
    return new LabelsLabel().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): LabelsLabel {
    return new LabelsLabel().fromJsonString(jsonString, options);
  }

  static equals(a: LabelsLabel | PlainMessage<LabelsLabel> | undefined, b: LabelsLabel | PlainMessage<LabelsLabel> | undefined): boolean {
    return proto3.util.equals(LabelsLabel, a, b);
  }
}

/**
 * @generated from message validation.RelabelConfig
 */
export class RelabelConfig extends Message<RelabelConfig> {
  /**
   * @generated from field: repeated string source_labels = 1;
   */
  sourceLabels: string[] = [];

  /**
   * @generated from field: optional string separator = 2;
   */
  separator?: string;

  /**
   * @generated from field: string regex = 3;
   */
  regex = "";

  /**
   * @generated from field: optional uint64 modulus = 4;
   */
  modulus?: bigint;

  /**
   * @generated from field: optional string target_label = 5;
   */
  targetLabel?: string;

  /**
   * @generated from field: optional string replacement = 6;
   */
  replacement?: string;

  /**
   * @generated from field: optional string action = 7;
   */
  action?: string;

  constructor(data?: PartialMessage<RelabelConfig>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "validation.RelabelConfig";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "source_labels", kind: "scalar", T: 9 /* ScalarType.STRING */, repeated: true },
    { no: 2, name: "separator", kind: "scalar", T: 9 /* ScalarType.STRING */, opt: true },
    { no: 3, name: "regex", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 4, name: "modulus", kind: "scalar", T: 4 /* ScalarType.UINT64 */, opt: true },
    { no: 5, name: "target_label", kind: "scalar", T: 9 /* ScalarType.STRING */, opt: true },
    { no: 6, name: "replacement", kind: "scalar", T: 9 /* ScalarType.STRING */, opt: true },
    { no: 7, name: "action", kind: "scalar", T: 9 /* ScalarType.STRING */, opt: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): RelabelConfig {
    return new RelabelConfig().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): RelabelConfig {
    return new RelabelConfig().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): RelabelConfig {
    return new RelabelConfig().fromJsonString(jsonString, options);
  }

  static equals(a: RelabelConfig | PlainMessage<RelabelConfig> | undefined, b: RelabelConfig | PlainMessage<RelabelConfig> | undefined): boolean {
    return proto3.util.equals(RelabelConfig, a, b);
  }
}

/**
 * @generated from message validation.RegexpRegexp
 */
export class RegexpRegexp extends Message<RegexpRegexp> {
  constructor(data?: PartialMessage<RegexpRegexp>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "validation.RegexpRegexp";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): RegexpRegexp {
    return new RegexpRegexp().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): RegexpRegexp {
    return new RegexpRegexp().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): RegexpRegexp {
    return new RegexpRegexp().fromJsonString(jsonString, options);
  }

  static equals(a: RegexpRegexp | PlainMessage<RegexpRegexp> | undefined, b: RegexpRegexp | PlainMessage<RegexpRegexp> | undefined): boolean {
    return proto3.util.equals(RegexpRegexp, a, b);
  }
}


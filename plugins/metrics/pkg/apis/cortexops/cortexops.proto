syntax = "proto3";
option go_package = "github.com/rancher/opni/plugins/metrics/pkg/apis/cortexops";

import "google/protobuf/empty.proto";
import "google/protobuf/duration.proto";
import "github.com/rancher/opni/pkg/apis/storage/v1/storage.proto";
import "google/api/annotations.proto";

package cortexops;

// The CortexOps service controls meta-operations for deploying and configuring
// Cortex in the upstream environment.
service CortexOps {
  rpc GetClusterConfiguration(google.protobuf.Empty) returns (ClusterConfiguration) {
    option (google.api.http) = {
      get: "/configuration"
    };
  }
  rpc ConfigureCluster(ClusterConfiguration) returns (google.protobuf.Empty) {
    option (google.api.http) = {
      post: "/configure"
      body: "*"
    };
  }
  rpc GetClusterStatus(google.protobuf.Empty) returns (InstallStatus) {
    option (google.api.http) = {
      get: "/status"
    };
  }
  rpc UninstallCluster(google.protobuf.Empty) returns (google.protobuf.Empty) {
    option (google.api.http) = {
      post: "/uninstall"
    };
  }
}

enum InstallState {
  Unknown = 0;
  NotInstalled = 1;
  Updating = 2;
  Installed = 3;
  Uninstalling = 4;
}

message InstallStatus {
  InstallState state = 1;
  string version = 2;
  map<string, string> metadata = 3;
}

enum DeploymentMode {
  AllInOne = 0;
  HighlyAvailable = 1;
}

message ClusterConfiguration {
  DeploymentMode mode = 1;
  storage.StorageSpec storage = 2;
  GrafanaConfig grafana = 3;
  Workloads workloads = 4;
  CortexConfig cortex = 5;
}

message Workloads {
  CortexWorkloadSpec distributor = 1;
  CortexWorkloadSpec ingester = 2;
  CortexWorkloadSpec compactor = 3;
  CortexWorkloadSpec storeGateway = 4;
  CortexWorkloadSpec ruler = 5;
  CortexWorkloadSpec queryFrontend = 6;
  CortexWorkloadSpec querier = 7;
  CortexWorkloadSpec purger = 8;
}

message CortexWorkloadSpec {
  optional int32 replicas = 1;
  repeated string extraArgs = 2;
}

message CortexConfig {
  optional CompactorConfig compactor = 1;
  optional QuerierConfig querier = 2;
  optional DistributorConfig distributor = 3;
  optional IngesterConfig ingester = 4;
}

message CompactorConfig {
  // List of compaction time ranges
  // Default: [2h, 12h, 24h]
  optional BlockRanges blockRanges = 1;
  // The frequency at which the compaction runs
  // Default: 1h
  optional google.protobuf.Duration compactionInterval = 2;
  // How frequently compactor should run blocks cleanup and maintenance, as well as update the bucket index
  // Default: 15m
  optional google.protobuf.Duration cleanupInterval = 3;
  // Time before a block marked for deletion is deleted from the bucket
  // Default: 12h
  optional google.protobuf.Duration deletionDelay = 4;
  // For tenants marked for deletion, this is time between deleting of last block, and doing final cleanup (marker files, debug files) of the tenant
  // Default: 6h
  optional google.protobuf.Duration tenantCleanupDelay = 5;
}

message BlockRanges {
  repeated google.protobuf.Duration ranges = 1;
}

message QuerierConfig {
  // The timeout for a query
  // Default: 2m
  optional google.protobuf.Duration queryTimeout = 1;

  // Maximum number of samples a single query can load into memory
  // Default: 50e6
  optional int32 maxSamples = 2;

  // Maximum lookback beyond which queries are not sent to ingester. 0 means all queries are sent to ingester.
  // Default: 0
  optional google.protobuf.Duration queryIngestersWithin = 3;

  // Maximum duration into the future you can query. 0 to disable
  // Default: 10m
  optional google.protobuf.Duration maxQueryIntoFuture = 4;

  // The default evaluation interval or step size for subqueries
  // Default: 1m
  optional google.protobuf.Duration defaultEvaluationInterval = 5;

  // The time after which a metric should be queried from storage and not just ingesters. 0 means all queries are sent to store.
  // When running the blocks storage, if this option is enabled, the time range of the query sent to the store will be manipulated
  // to ensure the query end is not more recent than 'now - query-store-after'.
  // Default: 0
  optional google.protobuf.Duration queryStoreAfter = 6;

  // Time since the last sample after which a time series is considered stale and ignored by expression evaluations
  // Default: 5m
  optional google.protobuf.Duration lookbackDelta = 7;

  // When distributor's sharding strategy is shuffle-sharding and this setting is > 0, queriers fetch in-memory series from
  // the minimum set of required ingesters, selecting only ingesters which may have received series since 'now - lookback period'.
  // The lookback period should be greater or equal than the configured 'query store after' and 'query ingesters within'.
  // If this setting is 0, queriers always query all ingesters (ingesters shuffle sharding on read path is disabled).
  // Default: 0
  optional google.protobuf.Duration shuffleShardingIngestersLookbackPeriod = 8;

  // The maximum number of unique series for which a query can fetch samples from each ingesters and blocks storage. This limit is enforced in the querier, ruler and store-gateway. 0 to disable
  // Default: 0
  optional int32 maxFetchedSeriesPerQuery = 9;
}


message DistributorConfig {
  // Per-user ingestion rate limit in samples per second.
  // Default: 600000
  optional double ingestionRate = 1;

  // Whether the ingestion rate limit should be applied individually to each distributor instance (local), or evenly shared across the cluster (global).
  // Default: "local"
  optional string ingestionRateStrategy = 2;

  // Per-user allowed ingestion burst size (in number of samples).
  // Default: 1000000
  optional int32 ingestionBurstSize = 3;
}

message IngesterConfig {
  // The maximum number of active series per user, per ingester. 0 to disable.
  // Default: 0
  optional int32 maxLocalSeriesPerUser = 1;

  // The maximum number of active series per metric name, per ingester. 0 to disable.
  // Default: 0
  optional int32 maxLocalSeriesPerMetric = 2;

  // The maximum number of active series per user, across the cluster before replication. 0 to disable.
  // Default: 0
  optional int32 maxGlobalSeriesPerUser = 3;

  // The maximum number of active series per metric name, across the cluster before replication. 0 to disable.
  // Default: 0
  optional int32 maxGlobalSeriesPerMetric = 4;

  // The maximum number of active metrics with metadata per user, per ingester. 0 to disable.
  // Default: 0
  optional int32 maxLocalMetricsWithMetadataPerUser = 5;

  // The maximum number of metadata per metric, per ingester. 0 to disable.
  // Default: 0
  optional int32 maxLocalMetadataPerMetric = 6;

  // The maximum number of active metrics with metadata per user, across the cluster. 0 to disable.
  // Default: 0
  optional int32 maxGlobalMetricsWithMetadataPerUser = 7;

  // The maximum number of metadata per metric, across the cluster. 0 to disable.
  // Default: 0
  optional int32 maxGlobalMetadataPerMetric = 8;
}

message GrafanaConfig {
  optional bool enabled = 1;
  string hostname = 2;
}
